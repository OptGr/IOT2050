{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","require","install","net","coreServer","internalDebugLog","message","payload","modbusServer","config","this","name","mbBasics","logEnabled","hostname","parseInt","serverPort","responseDelay","delayUnit","ModbusServer","bufferFactor","coilsBufferSize","holdingBufferSize","inputBufferSize","discreteBufferSize","modbusLogLevel","node","showErrors","setNodeStatusTo","settings","netServer","Server","modbus","server","TCP","logLabel","calc_rateByUnit","logLevel","alloc","coils","Buffer","discrete","on","socket","JSON","stringify","client","address","remoteAddress","remotePort","listen","showStatusActivities","setNodeDefaultStatus","err","buildMessage","msg","send","holding","type","input","isValidMemoryMessage","error","disableMsgOutput","done","close"],"mappings":"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","file":"../modbus-server.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const modbus = require('jsmodbus')\n  const net = require('net')\n  const coreServer = require('./core/modbus-server-core')\n  const mbBasics = require('./modbus-basics')\n  const internalDebugLog = require('debug')('contribModbus:server')\n\n  function ModbusServer (config) {\n    RED.nodes.createNode(this, config)\n    const bufferFactor = 8\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.hostname = config.hostname || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay) || 1\n    this.delayUnit = config.delayUnit\n\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\n    this.discreteBufferSize = parseInt(config.discreteBufferSize * bufferFactor)\n\n    this.showErrors = config.showErrors\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n\n    node.netServer = null\n    node.modbusServer = null\n\n    mbBasics.setNodeStatusTo('initialized', node)\n\n    let modbusLogLevel = 'warn'\n    if (RED.settings.verbose) {\n      modbusLogLevel = 'debug'\n    }\n\n    try {\n      node.netServer = new net.Server()\n      node.modbusServer = new modbus.server.TCP(node.netServer, {\n        logLabel: 'ModbusServer',\n        logLevel: modbusLogLevel,\n        logEnabled: node.logEnabled,\n        responseDelay: mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\n        coils: Buffer.alloc(node.coilsBufferSize, 0),\n        holding: Buffer.alloc(node.holdingBufferSize, 0),\n        input: Buffer.alloc(node.inputBufferSize, 0),\n        discrete: Buffer.alloc(node.discreteBufferSize, 0)\n      })\n\n      node.modbusServer.on('connection', function (client) {\n        internalDebugLog('Modbus Server client connection')\n        if (client && client.socket) {\n          internalDebugLog('Modbus Server client to ' + JSON.stringify(client.socket.address()) + ' from ' + client.socket.remoteAddress + ' ' + client.socket.remotePort)\n        }\n        mbBasics.setNodeStatusTo('active', node)\n      })\n\n      node.netServer.listen(node.serverPort, node.hostname, () => {\n        internalDebugLog('Modbus Server listening on modbus://' + node.hostname + ':' + node.serverPort)\n        mbBasics.setNodeStatusTo('initialized', node)\n      })\n\n      if (!node.showStatusActivities) {\n        mbBasics.setNodeDefaultStatus(node)\n      }\n    } catch (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.warn(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    }\n\n    node.on('input', function (msg) {\n      if (coreServer.isValidMemoryMessage(msg)) {\n        coreServer.writeToServerMemory(node, msg)\n        if (!msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      } else {\n        if (node.showErrors) {\n          node.error('Is Not A Valid Memory Write Message To Server', msg)\n        }\n        if (!msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      }\n    })\n\n    function buildMessage (msg) {\n      return [\n        { type: 'holding', message: msg, payload: node.modbusServer.holding },\n        { type: 'coils', message: msg, payload: node.modbusServer.coils },\n        { type: 'input', message: msg, payload: node.modbusServer.input },\n        { type: 'discrete', message: msg, payload: node.modbusServer.discrete },\n        { payload: 'request', type: 'message', message: msg }\n      ]\n    }\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.netServer) {\n        node.netServer.close(() => {\n          internalDebugLog('Modbus Server closed')\n          done()\n        })\n      }\n      node.modbusServer = null\n    })\n  }\n\n  try {\n    RED.nodes.registerType('modbus-server', ModbusServer)\n  } catch (err) {\n    internalDebugLog(err.message)\n  }\n}\n"]}