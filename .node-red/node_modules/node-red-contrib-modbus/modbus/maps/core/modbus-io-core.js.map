{"version":3,"sources":["core/modbus-io-core.js"],"names":["require","install","de","biancoroyal","modbus","io","core","internalDebug","LineByLineReader","nameValuesFromIOFile","node","msg","values","response","readingOffset","valueNames","ioCore","ioFile","configData","forEach","mapping","push","buildInputAddressMapping","Number","addressOffset","logIOActivities","buildOutputAddressMapping","valueAddress","startsWith","allValueNamesFromIOFile","ioNode","insertValues","getDataTypeFromFirstCharType","type","registerName","offset","logging","addressStartIO","addressStart","coilStart","bits","bitAddress","name","substring","registerType","addressType","split","Math","floor","addressOffsetIO","Bit","dataType","error","register","registerAddress","index","item","prototype","hasOwnProperty","call","JSON","stringify","value","pow","getValueFromBufferByDataType","bufferOffset","responseBuffer","registerLength","length","readUInt16BE","isRegisterSizeWrong","readInt8","readInt16BE","convertedValue","readIntBE","readFloatBE","readDoubleBE","readUInt32BE","readUIntBE","convertValuesByType","Object","readInt32BE","buffer","err","message","filterValueNames","fc","adr","quantity","functionType","startRegister","endRegister","filter","valueName","start","sizeDivisor","sixteenBitBufferLength","buildMessageWithIO","bufferMessageList","rawMsg","origMsg","modbusRequest","assign","payload","topic","lastUpdatedAt","parseInt","this","allValueNames","address","module","exports"],"mappings":"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","file":"../../core/modbus-io-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { io: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.internalDebug = de.biancoroyal.modbus.io.core.internalDebug || require('debug')('contribModbus:io:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.LineByLineReader = de.biancoroyal.modbus.io.core.LineByLineReader || require('line-by-line') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.core = de.biancoroyal.modbus.io.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.io.core.nameValuesFromIOFile = function (node, msg, values, response, readingOffset) {\n  let valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (node.ioFile && node.ioFile.configData) {\n    node.ioFile.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n    })\n  }\n\n  valueNames = ioCore.insertValues(valueNames, values, node.logIOActivities)\n\n  return ioCore.convertValuesByType(valueNames, values, response, node.logIOActivities)\n}\n\nde.biancoroyal.modbus.io.core.allValueNamesFromIOFile = function (ioNode) {\n  const valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (ioNode && ioNode.configData) {\n    ioNode.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n    })\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getDataTypeFromFirstCharType = function (type) {\n  switch (type) {\n    case 'w':\n      return 'Word'\n    case 'd':\n      return 'Double'\n    case 'r':\n      return 'Real'\n    case 'f':\n      return 'Float'\n    case 'i':\n      return 'Integer'\n    case 'l':\n      return 'Long'\n    case 'b':\n      return 'Boolean'\n    default:\n      return 'Unsigned Integer'\n  }\n}\n\nde.biancoroyal.modbus.io.core.buildInputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%IX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown input type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart: addressStart,\n      addressOffset: addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO: addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart: coilStart,\n      bitAddress: bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits: bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'input'\n    }\n  }\n\n  return { name: mapping.name, type: type, mapping: mapping, error: 'variable name does not match input mapping' }\n}\n\nde.biancoroyal.modbus.io.core.buildOutputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%QX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown output type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart: addressStart,\n      addressOffset: addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO: addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart: coilStart,\n      bitAddress: bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits: bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'output'\n    }\n  }\n\n  return { name: mapping.name, type: type, mapping: mapping, error: 'variable name does not match output mapping' }\n}\n\nde.biancoroyal.modbus.io.core.insertValues = function (valueNames, register, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  let index = 0\n  for (index in valueNames) {\n    const item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Insert Value ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    switch (Number(item.bits)) {\n      case 1:\n        item.value = !!((register[item.registerAddress] & Math.pow(item.bitAddress[1], 2)))\n        break\n      case 16:\n        item.value = register[item.registerAddress]\n        break\n      case 32:\n        item.value = register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 64:\n        item.value = register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 80:\n        item.value = register[item.registerAddress + 4] << 64 |\n          register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      default:\n        item.value = null\n        break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getValueFromBufferByDataType = function (item, bufferOffset, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  const registerLength = responseBuffer.length / 2\n\n  if (bufferOffset < 0 || bufferOffset > responseBuffer.length) {\n    if (logging) {\n      ioCore.internalDebug('Wrong Buffer Access Parameter Type:' + item.dataType + ' Register-Length: ' + registerLength +\n        ' Buffer-Length:' + responseBuffer.length + ' Address-Buffer-Offset:' + bufferOffset)\n      ioCore.internalDebug(JSON.stringify(item))\n    }\n    return item\n  }\n\n  if (logging) {\n    ioCore.internalDebug('Get Value From Buffer By Data Type:' + item.dataType + ' Register:' + item.registerAddress + ' Bits:' + Number(item.bits))\n  }\n\n  switch (item.dataType) {\n    case 'Boolean':\n      item.value = !!(responseBuffer.readUInt16BE(bufferOffset) & Math.pow(item.bitAddress[1], 2))\n      break\n    case 'Word':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset) // DWord\n          item.convertedValue = false\n      }\n      break\n    case 'Integer':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset)\n      }\n      break\n    case 'Real':\n    case 'Float':\n      item.value = responseBuffer.readFloatBE(bufferOffset, 4)\n      break\n    case 'Double':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 8)\n      break\n    case 'Long':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 10)\n      break\n    default:\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readUInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readUInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readUIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readUInt16BE(bufferOffset)\n          item.convertedValue = false\n      }\n      break\n  }\n\n  return item\n}\n\nde.biancoroyal.modbus.io.core.convertValuesByType = function (valueNames, register, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let bufferOffset = 0\n  const sixteenBitBufferLength = 2\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'dataType') || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Convert ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    if (responseBuffer.buffer instanceof Buffer) {\n      bufferOffset = Number(item.registerAddress) * sixteenBitBufferLength\n      try {\n        item = ioCore.getValueFromBufferByDataType(item, bufferOffset, responseBuffer.buffer, logging)\n      } catch (err) {\n        ioCore.internalDebug(err.message)\n      }\n    } else {\n      if (logging) {\n        ioCore.internalDebug('Response Buffer Is Not A Buffer')\n      }\n      break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.filterValueNames = function (node, valueNames, fc, adr, quantity) {\n  if (!valueNames.length || !valueNames.filter) {\n    return valueNames\n  }\n\n  const ioCore = de.biancoroyal.modbus.io.core\n  let functionType = 'input'\n\n  if (fc === 2 || fc === 4) {\n    functionType = 'output'\n  }\n\n  const startRegister = adr\n  const endRegister = Number(adr) + Number(quantity) - 1\n\n  if (node.logIOActivities) {\n    ioCore.internalDebug('adr:' + adr + ' quantity:' + quantity + ' startRegister:' + startRegister + ' endRegister:' + endRegister + ' functionType:' + functionType)\n  }\n\n  return valueNames.filter((valueName) => {\n    return (valueName.registerAddress >= 0 &&\n      valueName.addressStartIO >= startRegister &&\n      valueName.addressStartIO <= endRegister &&\n      valueName.type === functionType)\n  })\n}\n\nde.biancoroyal.modbus.io.core.isRegisterSizeWrong = function (register, start, bits) {\n  const sizeDivisor = Number(bits) || 16\n  const startRegister = Number(start)\n  let endRegister = startRegister\n\n  if (sizeDivisor > 16) {\n    endRegister = startRegister + (sizeDivisor / 16) - 1\n  }\n\n  return (startRegister < 0 || register.length < startRegister || endRegister > register.length)\n}\n\nde.biancoroyal.modbus.io.core.buildMessageWithIO = function (node, values, response, msg) {\n  const origMsg = this.core.getOriginalMessage(node.bufferMessageList, msg)\n  origMsg.modbusRequest = Object.assign({}, msg.payload)\n  origMsg.payload = values\n  origMsg.topic = msg.topic\n  origMsg.responseBuffer = response\n\n  const rawMsg = Object.assign({}, origMsg)\n  rawMsg.payload = response\n  rawMsg.values = values\n  delete rawMsg.responseBuffer\n\n  if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n    const allValueNames = this.nameValuesFromIOFile(node, msg, values, response, parseInt(msg.payload.address) || 0)\n    const valueNames = this.filterValueNames(node, allValueNames, parseInt(msg.payload.fc) || 3,\n      parseInt(msg.payload.address) || 0,\n      parseInt(msg.payload.quantity) || 1,\n      node.logIOActivities)\n\n    if (node.useIOForPayload) {\n      origMsg.payload = valueNames\n      origMsg.values = values\n    } else {\n      origMsg.payload = values\n      origMsg.valueNames = valueNames\n    }\n\n    rawMsg.valueNames = valueNames\n    return [origMsg, rawMsg]\n  } else {\n    return [origMsg, rawMsg]\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.io.core\n"]}