{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","require","install","coreModbusClient","coreModbusQueue","node","registerType","setStoppedState","config","nodes","createNode","this","serialConnectionDelayTimeMS","unlimitedListeners","defaultTcpUnitId","clienttype","undefined","timeoutTimeMS","reconnectTimeMS","serialAsciiResponseStartDelimiter","parallelUnitIdsAllowed","stateLogEnabled","tcpHost","bufferCommands","tcpPort","parseInt","tcpType","serialBaudrate","serialStopbits","serialPort","serialDatabits","serialConnectionDelay","serialType","unit_id","reconnectTimeout","commandDelay","reconnectOnTimeout","verboseWarn","logMessage","serverInfo","verbose","warn","settings","internalDebug","isFirstInitOfConnection","closingModbus","Map","client","bufferCommandList","messagesAllowedStates","sendingAllowed","messageAllowedStates","stateMachine","createStateMachineService","stateService","initialState","actualServiceState","actualServiceStateBefore","reconnectTimeoutId","internalDebugLog","setDefaultUnitId","ModbusClientNode","setUnitIdFromPayload","msg","getActualUnitId","unitId","checkUnitId","verboseLog","queueLogEnabled","state","value","matches","updateServerinfo","initQueue","setTimeout","connectClient","err","payload","logHintText","emit","queueSerialUnlockCommand","send","serialSendingAllowed","queueSerialLockCommand","close","message","ModbusRTU","clientTimeout","error","Error","connectC701","port","setTCPConnected","modbusTcpErrorHandling","connectTelnet","autoOpen","setTCPConnectionOptions","connectTcpRTUBuffered","connectTCP","serialPortOptions","baudRate","dataBits","stopBits","startOfSlaveFrameChar","toString","parity","serialParity","then","setSerialConnectionOptions","modbusSerialErrorHandling","connectRTU","connectRTUBuffered","setID","modbusSerialDebug","openSerialClient","JSON","stringify","errno","networkErrors","includes","modbusErrorHandling","code","showErrors","_port","on","onModbusClose","cb","cberr","indexOf","pushToQueueByUnitId","queueLength","get","queueUnitId","length","readModbus","info","writeModbus","queueLog","activateSending","checkQueuesAreEmpty","reject","Promise","mbBasics","invalidPayloadIn","setNewNodeSettings","setMaxListeners","done","nodeIdentifierName","name","removeAllListeners","isOpen","registeredNodeList","registerForModbus","clientUserNodeId","Object","keys","deregisterForModbus","httpAdmin","auth","needsPermission","req","res","json","ports"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:config:client')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const defaultTcpUnitId = 0\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n    const logHintText = ' Get More About It By Logging'\n    const serialAsciiResponseStartDelimiter = '0x3A'\n\n    this.clienttype = config.clienttype\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.bufferCommands = true\n    } else {\n      this.bufferCommands = config.bufferCommands\n    }\n\n    this.queueLogEnabled = config.queueLogEnabled\n    this.stateLogEnabled = config.stateLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n    this.serialAsciiResponseStartDelimiter = config.serialAsciiResponseStartDelimiter || serialAsciiResponseStartDelimiter\n\n    this.unit_id = parseInt(config.unit_id)\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.parallelUnitIdsAllowed = true\n    } else {\n      this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n    }\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendingAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messagesAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n    node.reconnectTimeoutId = 0\n    node.serialSendingAllowed = false\n    node.internalDebugLog = internalDebugLog\n\n    coreModbusQueue.queueSerialLockCommand(node)\n\n    node.setDefaultUnitId = function () {\n      if (this.clienttype === 'tcp') {\n        node.unit_id = defaultTcpUnitId\n      } else {\n        node.unit_id = defaultUnitId\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unitId = coreModbusClient.getActualUnitId(node, msg)\n      if (!coreModbusClient.checkUnitId(unitId, node.clienttype)) {\n        node.setDefaultUnitId()\n      }\n      node.client.setID(unitId)\n      msg.unitId = unitId\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.setDefaultUnitId()\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands && node.queueLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (!state.value || node.actualServiceState.value === undefined) {\n        // verboseWarn('fsm ignore invalid state')\n        return\n      }\n\n      if (node.actualServiceStateBefore.value === node.actualServiceState.value) {\n        // verboseWarn('fsm ignore equal state ' + node.actualServiceState.value + ' after ' + node.actualServiceStateBefore.value)\n        return\n      }\n\n      if (state.matches('init')) {\n        verboseWarn('fsm init state after ' + node.actualServiceStateBefore.value)\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n        node.reconnectTimeoutId = 0\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            verboseWarn('first fsm init in ' + serialConnectionDelayTimeMS + ' ms')\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            verboseWarn('fsm init in ' + node.reconnectTimeout + ' ms')\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          node.error(err, { payload: 'client connection error ' + logHintText })\n        }\n\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        verboseWarn('fsm connected after state ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbconnected')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands && !coreModbusQueue.checkQueuesAreEmpty(node)) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        if (node.clienttype === 'tcp') {\n          node.stateService.send('SEND')\n        } else {\n          if (node.serialSendingAllowed) {\n            coreModbusQueue.queueSerialLockCommand(node)\n            node.stateService.send('SEND')\n          }\n        }\n      }\n\n      if (state.matches('sending')) {\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbopen')\n      }\n\n      if (state.matches('switch')) {\n        node.emit('mbswitch')\n        node.stateService.send('CLOSE')\n      }\n\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('RECONNECT')\n      }\n\n      if (state.matches('stopped')) {\n        verboseWarn('stopped state without reconnecting')\n        node.emit('mbclosed')\n      }\n\n      if (state.matches('failed')) {\n        verboseWarn('fsm failed state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mberror', 'Modbus Failure On State ' + node.actualServiceStateBefore.value + logHintText)\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        verboseWarn('fsm broken state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mbbroken', 'Modbus Broken On State ' + node.actualServiceStateBefore.value + logHintText)\n        if (node.reconnectOnTimeout) {\n          node.stateService.send('RECONNECT')\n        } else {\n          node.stateService.send('ACTIVATE')\n        }\n      }\n\n      if (state.matches('reconnecting')) {\n        verboseWarn('fsm reconnect state after ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialLockCommand(node)\n        node.emit('mbreconnecting')\n        if (node.reconnectTimeout <= 0) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n        setTimeout(() => {\n          node.reconnectTimeoutId = 0\n          node.stateService.send('INIT')\n        }, node.reconnectTimeout)\n      }\n    })\n\n    node.connectClient = function () {\n      if (node.client) {\n        try {\n          node.client.close(function () {\n            verboseLog('connection closed')\n          })\n          verboseLog('connection close sent')\n        } catch (err) {\n          verboseLog(err.message)\n        }\n      }\n      node.client = null\n      node.client = new ModbusRTU()\n\n      if (!node.clientTimeout) {\n        node.clientTimeout = timeoutTimeMS\n      }\n\n      if (!node.reconnectTimeout) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n\n      if (node.clienttype === 'tcp') {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        switch (node.tcpType) {\n          case 'C701':\n            verboseLog('C701 port UDP bridge')\n            node.client.connectC701(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .then(node.setTCPConnected)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TELNET':\n            verboseLog('Telnet port')\n            node.client.connectTelnet(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TCP-RTU-BUFFERED':\n            verboseLog('TCP RTU buffered port')\n            node.client.connectTcpRTUBuffered(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          default:\n            verboseLog('TCP port')\n            node.client.connectTCP(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n        }\n      } else {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id serial (0..247)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        if (!node.serialConnectionDelay) {\n          node.serialConnectionDelay = serialConnectionDelayTimeMS\n        }\n\n        if (!node.serialPort) {\n          node.error(new Error('wrong serial port'), { payload: node.serialPort })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        const serialPortOptions = {\n          baudRate: parseInt(node.serialBaudrate),\n          dataBits: parseInt(node.serialDatabits),\n          stopBits: parseInt(node.serialStopbits),\n          parity: node.serialParity,\n          autoOpen: false\n        }\n\n        switch (node.serialType) {\n          case 'ASCII':\n            verboseLog('ASCII port serial')\n            // Make sure is parsed when string, otherwise just assign.\n            if (node.serialAsciiResponseStartDelimiter && typeof node.serialAsciiResponseStartDelimiter === 'string') {\n              serialPortOptions.startOfSlaveFrameChar = parseInt(node.serialAsciiResponseStartDelimiter, 16)\n            } else {\n              serialPortOptions.startOfSlaveFrameChar = node.serialAsciiResponseStartDelimiter\n            }\n            verboseLog('Using response delimiter: 0x' + serialPortOptions.startOfSlaveFrameChar.toString(16))\n\n            node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          case 'RTU':\n            verboseLog('RTU port serial')\n            node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          default:\n            verboseLog('RTU buffered port serial')\n            node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n        }\n      }\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n      }\n\n      if ((err.errno && coreModbusClient.networkErrors.includes(err.errno)) ||\n      (err.code && coreModbusClient.networkErrors.includes(err.code))) {\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n      }\n      node.stateService.send('BREAK')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.onModbusClose = function () {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      verboseWarn('Modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Read At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued read msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.readModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Write At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued write msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.writeModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.activateSending = function (msg) {\n      node.sendingAllowed.set(msg.queueUnitId, true)\n      coreModbusQueue.queueSerialUnlockCommand(node)\n\n      return new Promise(\n        function (resolve, reject) {\n          try {\n            if (node.bufferCommands) {\n              node.queueLog(JSON.stringify({\n                info: 'queue response activate sending',\n                queueLength: node.bufferCommandList.length,\n                sendingAllowed: node.sendingAllowed.get(msg.queueUnitId),\n                serialSendingAllowed: node.serialSendingAllowed,\n                queueUnitId: msg.queueUnitId\n              }))\n\n              if (coreModbusQueue.checkQueuesAreEmpty(node)) {\n                node.stateService.send('EMPTY')\n              }\n            }\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        })\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg, cb, cberr) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n      if (coreModbusClient.setNewNodeSettings(node, msg)) {\n        cb(msg)\n      } else {\n        cberr(new Error('Message Or Payload Not Valid'), msg)\n      }\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n      node.stateService.send('SWITCH')\n    })\n\n    node.on('close', function (done) {\n      const nodeIdentifierName = node.name || node.id\n      node.closingModbus = true\n      verboseLog('stop fsm on close ' + nodeIdentifierName)\n      node.stateService.send('STOP')\n      verboseLog('close node ' + nodeIdentifierName)\n      node.internalDebugLog('close node ' + nodeIdentifierName)\n      node.removeAllListeners()\n      if (node.client) {\n        if (node.client.isOpen) {\n          node.client.close(function (err) {\n            if (err) {\n              verboseLog('Connection closed with error ' + nodeIdentifierName)\n            } else {\n              verboseLog('Connection closed well ' + nodeIdentifierName)\n            }\n            done()\n          })\n        } else {\n          verboseLog('connection was closed ' + nodeIdentifierName)\n          done()\n        }\n      } else {\n        verboseLog('Connection closed simple ' + nodeIdentifierName)\n        done()\n      }\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (clientUserNodeId) {\n      node.registeredNodeList[clientUserNodeId] = clientUserNodeId\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('NEW')\n        node.stateService.send('INIT')\n      }\n      node.emit('mbregister', clientUserNodeId)\n    }\n\n    node.setStoppedState = function (clientUserNodeId, done) {\n      node.stateService.send('STOP')\n      node.emit('mbderegister', clientUserNodeId)\n      done()\n    }\n\n    node.closeConnectionWithoutRegisteredNodes = function (clientUserNodeId, done) {\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client && node.actualServiceState.value !== 'stopped') {\n          if (node.client.isOpen) {\n            node.client.close(function () {\n              node.setStoppedState(clientUserNodeId, done)\n            })\n          } else {\n            node.setStoppedState(clientUserNodeId, done)\n          }\n        } else {\n          node.setStoppedState(clientUserNodeId, done)\n        }\n      } else {\n        node.setStoppedState(clientUserNodeId, done)\n      }\n    }\n\n    node.deregisterForModbus = function (clientUserNodeId, done) {\n      try {\n        delete node.registeredNodeList[clientUserNodeId]\n        if (node.closingModbus) {\n          done()\n          node.emit('mbderegister', clientUserNodeId)\n        } else {\n          node.closeConnectionWithoutRegisteredNodes(clientUserNodeId, done)\n        }\n      } catch (err) {\n        verboseWarn(err.message + ' on de-register node ' + clientUserNodeId)\n        node.error(err)\n        done()\n      }\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      res.json([err.message])\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}