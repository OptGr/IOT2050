"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const fs = require("fs");
const path = require("path");
const utils_1 = require("../../api/utils");
const command_utils_1 = require("./command-utils");
const mobile_app_instances_1 = require("./mobile-app-instances");
let color = (0, command_utils_1.getColor)("magenta");
exports.default = (program) => {
    program
        .command("mobile-apps")
        .alias("mb")
        .option("-m, --mode [list|info|create|delete|update|template]", "mode [list | info | create | delete | update | template]", "list")
        .option("-t, --type [ios|android]", "type [ios|android]", "android")
        .option("-p, --appid <appid>", "mobile app id ")
        .option("-f, --file <file>", "mobile app file [ios|android].mobileapp.mdsp.json")
        .option("-a, --all", "list full app information")
        .option("-o, --overwrite", "overwrite template files")
        .option("-k, --passkey <passkey>", "passkey")
        .option("-y, --retry <number>", "retry attempts before giving up", "3")
        .option("-v, --verbose", "verbose output")
        .description(color(`list, create or delete mobile apps *`))
        .action((options) => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                checkRequiredParameters(options);
                const sdk = (0, command_utils_1.getSdk)(options);
                color = (0, command_utils_1.adjustColor)(color, options);
                (0, command_utils_1.homeDirLog)(options.verbose, color);
                (0, command_utils_1.proxyLog)(options.verbose, color);
                switch (options.mode) {
                    case "template":
                        yield createAppTemplate(options);
                        console.log("Edit the files before submitting them to mindsphere.");
                        break;
                    case "update":
                    case "create":
                        yield createOrUpdateApp(options, sdk);
                        break;
                    case "list":
                        yield listMobileApps(options, sdk);
                        break;
                    case "info":
                        {
                            options.all = true;
                            // hack as there is no parameterized get method
                            console.log(`App with ${options.appid}:\n`);
                            yield listMobileApps(options, sdk);
                            console.log(`Mobile App instances:\n`);
                            yield (0, mobile_app_instances_1.listInstances)(options, sdk);
                        }
                        break;
                    case "delete":
                        yield deleteApp(options, sdk);
                        break;
                    default:
                        throw Error(`no such option: ${options.mode}`);
                }
            }
            catch (err) {
                (0, command_utils_1.errorLog)(err, options.verbose);
            }
        }))();
    })
        .on("--help", () => printHelp());
};
function printHelp() {
    (0, console_1.log)("\n  Examples:\n");
    (0, console_1.log)(`    mc mobile-apps --mode list \t\t\t\t\tlist mobile apps`);
    (0, console_1.log)(`    mc mobile-apps --mode template --type [android|ios] \tcreate template file for mobileapp`);
    (0, console_1.log)(`    mc mobile-apps --mode create --file [android|ios].mobileapp.mdsp.json\tcreate mobileapp`);
    (0, console_1.log)(`    mc mobile-apps --mode info --appid <appid>\t\t\tmobile app info`);
    (0, console_1.log)(`    mc mobile-apps --mode delete --appid <appid>\t\tdelete mobile app`);
    (0, command_utils_1.serviceCredentialLog)();
}
function listMobileApps(options, sdk) {
    var e_1, _a;
    var _b;
    return __awaiter(this, void 0, void 0, function* () {
        const mobileAppsClient = sdk.GetNotificationClientV4();
        let page = 1; // the mobile apps client is starting paging from 1 for some strange reason
        let mobileapps;
        console.log(`appId  [type]\t${color("name")} [instance count]`);
        let appCount = 0;
        do {
            const params = { page: page, size: 20 };
            mobileapps = (yield (0, utils_1.retry)(options.retry, () => mobileAppsClient.GetMobileApps(params)));
            mobileapps.mobileApps = mobileapps.mobileApps || [];
            mobileapps.page = mobileapps.page || { totalPages: 0 };
            try {
                for (var _c = (e_1 = void 0, __asyncValues(mobileapps.mobileApps || [])), _d; _d = yield _c.next(), !_d.done;) {
                    const mobileApp = _d.value;
                    // there is no info method for GET so we are using this way to do this
                    if (options.appid && mobileApp.id !== options.appid)
                        continue;
                    appCount++;
                    const instances = yield mobileAppsClient.GetMobileAppsInstances(`${mobileApp.id}`);
                    console.log(`${mobileApp.id} [${mobileApp.type}]\t${color(mobileApp.name)} [${((_b = instances.page) === null || _b === void 0 ? void 0 : _b.totalElements) || 0}]`);
                    options.all && console.log(`${color(mobileApp.type)} properties:`);
                    options.all &&
                        (mobileApp.type === "android" ? console.table(mobileApp.android) : console.table(mobileApp.ios));
                    (0, command_utils_1.verboseLog)(JSON.stringify(mobileApp, null, 2), options.verbose);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) yield _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        } while (page++ < (mobileapps.page.totalPages || 0));
        console.log(`${color(appCount)} mobileapps listed.\n`);
    });
}
function createAppTemplate(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const template = options.type === "android"
            ? {
                name: "string",
                type: "android",
                android: {
                    fcmServerKey: "string",
                },
            }
            : {
                name: "string",
                type: "iOS",
                ios: {
                    fcmServerKey: "string",
                    bundleId: "string",
                    apnsSslCertificate: "string",
                    apnsAppPrivateKey: "string",
                    production: false,
                },
            };
        const fileName = options.file || `${options.type}.mobileapp.mdsp.json`;
        const filePath = path.resolve(fileName);
        fs.existsSync(filePath) && !options.overwrite && (0, utils_1.throwError)(`the file ${filePath} already exists.`);
        fs.writeFileSync(filePath, JSON.stringify(template, null, 2));
        console.log(`The ${color(options.type)} template file was written into ${color(fileName)}`);
        console.log(`Run:\n\n\
              \tmc mobile-apps --mode create --file ${fileName}
              \nto create mobile app in mindsphere.`);
    });
}
function createOrUpdateApp(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const mobileAppsClient = sdk.GetNotificationClientV4();
        const filePath = path.resolve(options.file);
        const filecontent = fs.readFileSync(filePath);
        const filedata = JSON.parse(filecontent.toString());
        if (options.mode === "create") {
            const result = (yield (0, utils_1.retry)(options.retry, () => __awaiter(this, void 0, void 0, function* () { return mobileAppsClient.PostMobileApp(filedata); })));
            console.log(`Mobile app with name ${color(result.name)} and type ${color(result.type)} was created.`);
        }
        else if (options.mode === "update") {
            const result = (yield (0, utils_1.retry)(options.retry, () => __awaiter(this, void 0, void 0, function* () {
                return mobileAppsClient.PatchMobileApp(options.appid, filedata);
            })));
            console.log(`Mobile app with name ${color(result.name)} and type ${color(result.type)} was updated.`);
        }
        else {
            throw Error(`Invalid mode in createOrUpdateMobileApp ${options.mode}`);
        }
    });
}
function deleteApp(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const mobileAppsClient = sdk.GetNotificationClientV4();
        yield (0, utils_1.retry)(options.retry, () => mobileAppsClient.DeleteMobileApp(options.appid));
        console.log(`App with id ${color(options.appid)} was deleted.`);
    });
}
function checkRequiredParameters(options) {
    options.mode === "create" &&
        !options.file &&
        (0, command_utils_1.errorLog)("you have to specify the --file for --mode create command", true);
    options.mode === "update" && !options.file && (0, command_utils_1.errorLog)("you have to specify the --file for --update command", true);
    (options.mode === "delete" || options.mode === "update" || options.mode === "info") &&
        !options.appid &&
        (0, command_utils_1.errorLog)("you have to specify the appid of the mobile app", true);
}
//# sourceMappingURL=mobile-apps.js.map