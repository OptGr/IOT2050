"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
require("url-search-params-polyfill");
const sdk_1 = require("../src/api/sdk");
const utils_1 = require("../src/api/utils");
const test_utils_1 = require("./test-utils");
chai.should();
describe("[SDK] Identity Management Client", () => {
    const auth = (0, utils_1.loadAuth)();
    const sdk = new sdk_1.MindSphereSdk(Object.assign(Object.assign({}, auth), { basicAuth: (0, utils_1.decrypt)(auth, (0, test_utils_1.getPasskeyForUnitTest)()) }));
    const identity = sdk.GetIdentityManagementClient();
    const username = `${new Date().getTime()}@unit.test.mindconnect.rocks`;
    const group = `unit.test.mindconnect.rocks.${new Date().getTime()}`;
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        yield cleanup(identity);
    }));
    after(() => __awaiter(void 0, void 0, void 0, function* () {
        yield cleanup(identity);
    }));
    it("should instantiate", () => __awaiter(void 0, void 0, void 0, function* () {
        identity.should.not.be.undefined;
    }));
    it("should list all users @sanity", () => __awaiter(void 0, void 0, void 0, function* () {
        const users = yield identity.GetUsers();
        users.totalResults.should.be.greaterThan(0);
    }));
    it("should list all users with attributes", () => __awaiter(void 0, void 0, void 0, function* () {
        const users = yield identity.GetUsers({ attributes: "userName" });
        users.totalResults.should.be.greaterThan(0);
    }));
    it("should list all users sorted", () => __awaiter(void 0, void 0, void 0, function* () {
        const users = yield identity.GetUsers({ sortBy: "userName" });
        users.totalResults.should.be.greaterThan(0);
    }));
    it("the user crud operations on Users should work", () => __awaiter(void 0, void 0, void 0, function* () {
        const createdUser = yield identity.PostUser({ userName: username });
        createdUser.should.not.be.null;
        createdUser.userName.should.equal(username);
        const extId = new Date().getTime().toString();
        createdUser.externalId = extId;
        const updatedUser = yield identity.PutUser(createdUser.id, createdUser);
        updatedUser.externalId.should.equal(extId);
        const user = yield identity.GetUser(createdUser.id);
        user.userName.should.equal(username);
        const result = yield identity.DeleteUser(createdUser.id);
        result.userName.should.equal(username);
    }));
    it("the user crud operations on Groups should work", () => __awaiter(void 0, void 0, void 0, function* () {
        const createdGroup = yield identity.PostGroup({ displayName: group, description: group });
        createdGroup.should.not.be.null;
        createdGroup.displayName.should.equal(group);
        createdGroup.description.should.equal(group);
        createdGroup.description = `${group}-updated`;
        const updatedGroup = yield identity.PutGroup(createdGroup.id, createdGroup);
        updatedGroup.description.should.equal(`${group}-updated`);
        const requestedGroup = yield identity.GetGroup(updatedGroup.id);
        requestedGroup.displayName.should.equal(`${group}`);
        const searchedGroups = yield identity.GetGroups({ filter: `displayName sw "unit.test.mindconnect.rocks"` });
        searchedGroups.totalResults.should.equal(1);
        const deletedGroup = yield identity.DeleteGroup(createdGroup.id);
        deletedGroup.id.should.equal(createdGroup.id);
    }));
    it("the crud operations on GroupMembers should work", () => __awaiter(void 0, void 0, void 0, function* () {
        const grpName = `unit.test.mindconnect.rocks.${new Date().getTime()}`;
        const createdGroup = yield identity.PostGroup({
            displayName: grpName,
            description: grpName,
        });
        createdGroup.should.not.be.null;
        createdGroup.displayName.should.equal(grpName);
        createdGroup.description.should.equal(grpName);
        const member = yield identity.PostUser({ userName: `${new Date().getTime()}@unit.test.mindconnect.rocks` });
        member.id.should.not.be.undefined;
        const assign = yield identity.PostGroupMember(createdGroup.id, {
            type: sdk_1.IdentityManagementModels.ScimGroupMember.TypeEnum.USER,
            value: member.id,
        });
        assign.value.should.equal(member.id);
        const members = yield identity.GetGroupMembers(createdGroup.id);
        members.length.should.equal(1);
        const remove = yield identity.DeleteGroupMember(createdGroup.id, member.id);
        remove.value.should.equal(member.id);
        const updatedMembers = yield identity.GetGroupMembers(createdGroup.id);
        updatedMembers.length.should.equal(0);
        const deletedGroup = yield identity.DeleteGroup(createdGroup.id);
        deletedGroup.id.should.equal(createdGroup.id);
        const deletedUser = yield identity.DeleteUser(member.id);
        deletedUser.id.should.equal(member.id);
    }));
});
function cleanup(identity) {
    return __awaiter(this, void 0, void 0, function* () {
        const groups = yield (yield identity.GetGroups({ filter: `displayName sw "unit.test.mindconnect.rocks"` }))
            .resources;
        for (let index = 0; index < groups.length; index++) {
            const element = groups[index];
            yield identity.DeleteGroup(element.id);
        }
        const users = yield (yield identity.GetUsers({ sortBy: "userName", attributes: "id,userName" })).resources.filter((x) => { var _a; return (_a = x.userName) === null || _a === void 0 ? void 0 : _a.endsWith("unit.test.mindconnect.rocks"); });
        for (let index = 0; index < users.length; index++) {
            const element = users[index];
            yield identity.DeleteUser(element.id);
        }
    });
}
//# sourceMappingURL=identity-management.spec.js.map