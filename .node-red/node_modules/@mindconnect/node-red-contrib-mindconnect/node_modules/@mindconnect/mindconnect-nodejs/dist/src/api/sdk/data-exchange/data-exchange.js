"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataExchangeClient = void 0;
const utils_1 = require("../../utils");
const sdk_client_1 = require("../common/sdk-client");
const data_exchange_template_1 = require("./data-exchange-template");
/**
 *
 * Offers data transfer operations as part of the Analytics package,
 * in a single endpoint providing various operations like upload/download, move, (recursive) delete,
 * share within tenant.It also provides an abstraction that helps callers easily share files and folders
 * between the users of tHe same tenant, while allowing uploads with different visibilities private, or
 * public (within a tenant only) When looking to p[lace a file or directory
 * (either when creating a new one or moving it) into the root of the storage,
 * simply set the parentId of the file or folder to one of the "_PUBLIC_ROOT_ID" or "_PRIVATE_ROOT_ID"
 * allowing in this way to specify its visibility space.
 *
 * Allowed and safe characters to use in both filename and directyory names are the following:
 * Alphanumeric characters [0-9a-zA-Z]
 * Special characters -, _, ., (, ), and the space character The following are examples of valid object key names:
 * 4my-data
 * _test_dir./myfile.csv
 * Not allowed is using &$@=;:+,?,^{}%`[]"<>#|~!*' in filenames and directory names.
mode
The maximum length of the composed path, that is filename and directories names separated by '/' that is used in a request is 1024 bytes in UTF-8 encoding.
 *
 *
 * @export
 * @class DataExchangeClient
 * @extends {SdkClient}
 */
class DataExchangeClient extends sdk_client_1.SdkClient {
    constructor() {
        super(...arguments);
        this._baseUrl = "/api/dataexchange/v3";
    }
    /**
     * * Files
     *
     * Performs a new file upload
     *
     * Uploads a file using the specified form data parameters, and returns the created file resource.
     * The service verifies whether the user or the tenant under which the operation occurs has access
     * to the specified parent and generates an error in case of an unautorhized access.
     *
     * @param {DataExchangeModels.ResourcePatch} metadata
     * @param {Buffer} file
     * @returns {Promise<DataExchangeModels.File>}
     *
     * @memberOf DataExchangeClient
     */
    PostFile(metadata, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = (0, data_exchange_template_1.dataExchangeTemplate)(metadata, file);
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/files`,
                body: body,
                multiPartFormData: true,
                additionalHeaders: { enctype: "multipart/form-data" },
            });
            return result;
        });
    }
    /**
     * * Files
     *
     * Downloads the file identified by the specified ID.
     *
     * @param {string} id
     * @returns {Promise<Response>}
     *
     * @memberOf DataExchangeClient
     */
    GetFile(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/files/${id}`,
                additionalHeaders: { "Content-Type": "application/octet-stream" },
                rawResponse: true,
            });
            return result;
        });
    }
    /**
     * * Files
     *
     * Uploads a file on top of an existing file
     *
     * @param {string} id
     * @param {Buffer} file
     * @returns {Promise<DataExchangeModels.File>}
     *
     * @memberOf DataExchangeClient
     */
    PutFile(id, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = (0, data_exchange_template_1.putFileTemplate)(file);
            const result = yield this.HttpAction({
                verb: "PUT",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/files/${id}`,
                body: body,
                multiPartFormData: true,
                additionalHeaders: { enctype: "multipart/form-data" },
            });
            return result;
        });
    }
    /**
     * * Files
     *
     * Deletes a file (both metadata and the actual content).
     *
     * @param {string} id
     *
     * @memberOf DataExchangeClient
     */
    DeleteFile(id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.HttpAction({
                verb: "DELETE",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/files/${id}`,
                noResponse: true,
            });
        });
    }
    /**
     *
     * Retrieves metadata of the file identified by the specified ID.
     *
     * @param {string} id
     * @returns {Promise<DataExchangeModels.File>}
     *
     * @memberOf DataExchangeClient
     */
    GetFileProperties(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/files/${id}/properties`,
                // !fix: manual fix - this is actually illegal call according to mindsphere rules
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * * Files
     *
     * Allows updating specific properties associated with the file, namely its name and parent (by ID).
     * Updating the visibility (namely tenant-wide or user-only) for a file is not available but can be achieved
     * via changing the current file's parent to a directory that has a different visibility space.
     *
     * @param {string} id
     * @param {DataExchangeModels.ResourcePatch} options
     * @returns {Promise<DataExchangeModels.File>}
     *
     * @memberOf DataExchangeClient
     */
    PatchFileProperties(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "PATCH",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/files/${id}/properties`,
                body: options,
            });
            return result;
        });
    }
    /**
     * * Directories
     *
     * creates a directory
     *
     * @param {DataExchangeModels.ResourcePatch} metadata
     * @returns {Promise<DataExchangeModels.Directory>}
     *
     * @memberOf DataExchangeClient
     */
    PostDirectory(metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/directories`,
                body: metadata,
            });
            return result;
        });
    }
    /**
     *
     * Retreives updatable directory options, i.e the name and the parentId.
     *
     * @param {string} id
     * @returns {Promise<DataExchangeModels.Directory>}
     *
     * @memberOf DataExchangeClient
     */
    GetDirectoryProperties(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/directories/${id}/properties`,
                // !fix: manual fix - this is actually illegal call according to mindsphere rules
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * * Directories
     *
     * Allows updating directory's properties.
     *
     * Allows updating directory metadata, including the parentId (which triggers a move of the current directory),
     * or its visibility by moving it under a parentId that has a different visibility,
     * causing this change to propagate to its inner contents.
     * Changing the parentId to a parent that already contains a folder with the same name is not possible,
     * an error will be thrown.
     *
     * @param {string} id
     * @param {DataExchangeModels.ResourcePatch} options
     * @returns {Promise<DataExchangeModels.Directory>}
     *
     * @memberOf DataExchangeClient
     */
    PatchDirectoryProperties(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "PATCH",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/directories/${id}/properties`,
                body: options,
            });
            return result;
        });
    }
    /**
     *
     * * Directories
     *
     * Using GET on this endpoint to get a list of the source's contents
     *
     * Specifies the id for which it will list the contents.
     * By convention, when listing a root folder also implies specifying the visibility
     *  that the caller is looking after, that is, if listing the private space root, then this parameter requires
     * "_PUBLIC_ROOT_ID" or "_PRIVATE_ROOT_ID" value instead of a real directory id.
     *
     * @param {string} id
     * @param {{ pageNumber?: number; pageSize?: number; filter: string }} params
     * @returns {Promise<DataExchangeModels.DirectoriesFilesArray>}
     *
     * @memberOf DataExchangeClient
     */
    GetDirectory(id, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const parameters = params || {};
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/directories/${id}?${(0, utils_1.toQueryString)(parameters)}`,
            });
            return result;
        });
    }
    /**
     * * Directories
     *
     * Deletes a directory and its contents if recursive=true
     *
     * @param {string} id
     * @param {{ recursive?: boolean }} [params]
     *
     * @param params.recursive specifies if the deletion will be performed recursively
     *
     * @memberOf DataExchangeClient
     */
    DeleteDirectory(id, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const parameters = params || {};
            yield this.HttpAction({
                verb: "DELETE",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/directories/${id}?${(0, utils_1.toQueryString)(parameters)}`,
                noResponse: true,
            });
        });
    }
}
exports.DataExchangeClient = DataExchangeClient;
//# sourceMappingURL=data-exchange.js.map