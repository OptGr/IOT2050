"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserAuth = void 0;
const cross_fetch_1 = require("cross-fetch");
const utils_1 = require("./utils");
function log(message) {
    if (typeof window !== "undefined" && window.DEBUGSDK === true) {
        console.log(message);
    }
}
/**
 * If the SDK is run in Browser this class implements the necessary HTTP handling.
 *
 * @export
 * @class BrowserAuth
 * @implements {TokenRotation}
 */
class BrowserAuth {
    constructor() {
        this._headers = {
            Accept: "*/*",
            "X-Powered-By": "meowz",
        };
        /**
         * Http headers used for /exchange endpoint handling.
         *
         * @protected
         * @memberof MindConnectBase
         */
        this._multipartHeaders = Object.assign(Object.assign({}, this._headers), { "Content-Type": "multipart/mixed; boundary=mindspheremessage" });
        this._multipartFormData = Object.assign(Object.assign({}, this._headers), { "Content-Type": "multipart/form-data; boundary=--mindsphere" });
        /**
         * Http headers used for onboarding message.
         *
         * @protected
         * @memberof MindConnectBase
         */
        this._apiHeaders = Object.assign(Object.assign({}, this._headers), { "Content-Type": "application/json" });
        this._octetStreamHeaders = Object.assign(Object.assign({}, this._headers), { "Content-Type": "application/octet-stream" });
        /**
         * Http headers used to register the client assertion and acquire the /exchange token.
         *
         * @protected
         * @memberof MindConnectBase
         */
        this._urlEncodedHeaders = Object.assign(Object.assign({}, this._headers), { "Content-Type": "application/x-www-form-urlencoded" });
    }
    /**
     * perform http action
     *
     * @param {({
     *         verb: "GET" | "POST" | "PATCH" | "PUT" | "DELETE";
     *         gateway: string;
     *         baseUrl: string;
     *         authorization: string;
     *         body?: Object;
     *         message?: string;
     *         octetStream?: boolean;
     *         multiPartFormData?: boolean;
     *         additionalHeaders?: Object;
     *         noResponse?: boolean;
     *         rawResponse?: boolean;
     *         returnHeaders?: boolean;
     *         ignoreCodes?: number[];
     *     })} {
     *         verb,
     *         gateway,
     *         baseUrl,
     *         authorization,
     *         body,
     *         message,
     *         octetStream,
     *         multiPartFormData,
     *         additionalHeaders,
     *         noResponse,
     *         rawResponse,
     *         returnHeaders,
     *         ignoreCodes,
     *     }
     * @returns {Promise<Object>}
     *
     * @memberOf MindConnectBase
     */
    HttpAction({ verb, gateway, baseUrl, authorization, body, message, octetStream, multiPartFormData, additionalHeaders, noResponse, rawResponse, returnHeaders, ignoreCodes, }) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders = additionalHeaders || {};
            let apiheaders = octetStream ? this._octetStreamHeaders : this._apiHeaders;
            apiheaders = multiPartFormData ? this._multipartFormData : apiheaders;
            ignoreCodes = ignoreCodes || [];
            let headers = Object.assign({}, apiheaders);
            if (verb === "GET" || verb === "DELETE") {
                delete headers["Content-Type"];
            }
            const xsrfTokenFromCookie = this.getCookieValue("XSRF-TOKEN");
            if (xsrfTokenFromCookie && xsrfTokenFromCookie !== "") {
                headers["x-xsrf-token"] = xsrfTokenFromCookie;
                log(`Set x-xsrf-token to ${headers["x-xsrf-token"]}`);
            }
            else {
                log("There is no XSRF-TOKEN cookie.");
            }
            headers = (0, utils_1.removeUndefined)(Object.assign(Object.assign({}, headers), additionalHeaders));
            const url = `${baseUrl}`;
            log(`${message || ""} Headers ${JSON.stringify(headers)} Url ${url}`);
            try {
                const request = { method: verb, headers: headers, credentials: "include" };
                if (verb !== "GET" && verb !== "DELETE") {
                    request.body = octetStream || multiPartFormData ? body : JSON.stringify(body);
                }
                const f = typeof window === "undefined" ? cross_fetch_1.default : window.fetch;
                const response = yield f(url, request);
                const codeIgnored = ignoreCodes.indexOf(response.status) >= 0;
                !codeIgnored && !response.ok && (0, utils_1.throwError)(`${response.statusText} ${yield response.text()}`);
                !codeIgnored &&
                    (response.status < 200 || response.status > 299) &&
                    (0, utils_1.throwError)(`invalid response ${JSON.stringify(response)}`);
                if (codeIgnored)
                    return undefined;
                if (rawResponse)
                    return response;
                if (noResponse) {
                    if (returnHeaders) {
                        return response.headers;
                    }
                    return {};
                }
                const json = yield response.json();
                log(`${message} Response ${JSON.stringify(json)}`);
                return json;
            }
            catch (err) {
                log(err);
                throw new Error(`Network error occured ${err.message}`);
            }
        });
    }
    /**
     * * Returns true; MindSphere Gateway is taking care of this
     *
     * @returns {Promise<boolean>}
     *
     * @memberOf BrowserAuth
     */
    RenewToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return true; // the mindsphere gateway is doing this for us
        });
    }
    /**
     * * Returns ""; MindSphere Gateway is taking care of this
     *
     * @returns {Promise<string>}
     *
     * @memberOf BrowserAuth
     */
    GetToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return ""; // the mindsphere gateway is doing this for us
        });
    }
    /**
     * * Returns ""; MindSphere Gateway is taking care of this
     *
     * @returns {string}
     *
     * @memberOf BrowserAuth
     */
    GetGateway() {
        return ""; // the mindsphere gateway is doing this for us
    }
    /**
     *
     * * Returns ""; MindSphere Gateway is taking care of this
     *
     * @returns {string}
     *
     * @memberOf BrowserAuth
     */
    GetTenant() {
        return ""; // the mindsphere gateway is doing this for us
    }
    getCookieValue(a) {
        if (!document) {
            return undefined;
        }
        const b = document.cookie.match("(^|;)\\s*" + a + "\\s*=\\s*([^;]+)");
        return b ? b.pop() : "";
    }
}
exports.BrowserAuth = BrowserAuth;
//# sourceMappingURL=browser-auth.js.map