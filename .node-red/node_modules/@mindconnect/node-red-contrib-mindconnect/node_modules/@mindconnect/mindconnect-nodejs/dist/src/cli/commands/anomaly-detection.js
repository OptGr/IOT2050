"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const fs = require("fs");
const path = require("path");
const utils_1 = require("../../api/utils");
const command_utils_1 = require("./command-utils");
let color = (0, command_utils_1.getColor)("blue");
exports.default = (program) => {
    program
        .command("anomaly-detection")
        .alias("ad")
        .option("-m, --mode [template|train|detect]", "mode [template | train | detect]", "train")
        .option("-o, --on [data|asset]", // NOTE: 29/04/2021 - batch are excluded for now
    "on [data | asset]", // NOTE: 29/04/2021 - batch are excluded for now
    "data")
        .option("-d, --data <data>", "time series data file", "timeseries.mdsp.json")
        .option("-e, --epsilon <epsilon>", "threshold distance")
        .option("-s, --clustersize <clustersize>", "minimum cluster size")
        .option("-a, --algorithm [EUCLIDEAN|MANHATTAN|CHEBYSHEV]", "distance measure algorithm [EUCLIDEAN | MANHATTAN | CHEBYSHEV]")
        .option("-n, --modelname <modelname>", "human-friendly name of the model")
        .option("-i, --modelid <modelid>", "mindsphere model id ")
        .option("-i, --assetid <assetid>", "mindsphere asset id ")
        .option("-n, --aspectname <aspectname>", "mindsphere aspect name")
        .option("-f, --from <from>", "begining of the time range")
        .option("-u, --to <to>", "end of the time range")
        .option("-k, --passkey <passkey>", "passkey")
        .option("-y, --retry <number>", "retry attempts before giving up", "3")
        .option("-v, --verbose", "verbose output")
        .description(color(`train anomaly detection models and detect timeseries anomalies *`))
        .action((options) => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                checkRequiredParameters(options);
                const sdk = (0, command_utils_1.getSdk)(options);
                color = (0, command_utils_1.adjustColor)(color, options, true);
                (0, command_utils_1.homeDirLog)(options.verbose, color);
                (0, command_utils_1.proxyLog)(options.verbose, color);
                switch (options.mode) {
                    case "template":
                        yield createTemplate(options, sdk);
                        console.log("Edit the files before submitting them to mindsphere.");
                        break;
                    case "train":
                        yield trainNewModel(options, sdk);
                        break;
                    case "detect":
                        yield detectAnomalies(options, sdk);
                        break;
                    default:
                        throw Error(`no such option: ${options.mode}`);
                }
            }
            catch (err) {
                (0, command_utils_1.errorLog)(err, options.verbose);
            }
        }))();
    })
        .on("--help", () => printHelp());
};
function printHelp() {
    (0, console_1.log)("\n  Examples:\n");
    (0, console_1.log)(`    mc ad --mode template --data timeseries.data.mdsp.json \n \
                creates a template for a time series data file`);
    (0, console_1.log)(`    mc ad --mode train --on data --data timeseries.data.mdsp.json --epsilon 0.5 \n
                trains a model on the timeserie specified in the data file`);
    (0, console_1.log)(`    mc ad --mode detect --on data --data timeseries.data.mdsp.json --modelid <modelid>\n \
                detects anomalities of the timeseries in the data file using the model with specified id`);
    (0, console_1.log)(`    mc ad --mode train --on asset --assetid <assetid> --aspectname Environment --epsilon 0.5\n\
                trains a model on the time series of the aspect "Environment" of the asset with the id <assetid>`);
    (0, console_1.log)(`    mc ad --mode detect --on asset --modelid <modelid> --assetid <assetid> --aspectname Environment --epsilon 0.5\n\
                detect anomalities of the timeseries on the specified asset and aspect with selected model`);
    (0, command_utils_1.serviceCredentialLog)();
}
function checkRequiredParameters(options) {
    options.mode === "template" &&
        !options.data &&
        (0, command_utils_1.errorLog)("you have to specify the output file of timeserie data", true);
    options.mode === "detect" && !options.modelid && (0, command_utils_1.errorLog)("you have to specify the modelid", true);
    options.mode === "train" && !options.epsilon && (0, command_utils_1.errorLog)("you have to specify the threshold distance", true);
    options.on === "data" && !options.data && (0, command_utils_1.errorLog)("you have to specify the timeserie data file", true);
    options.on === "asset" && !options.assetid && (0, command_utils_1.errorLog)("you have to specify the targeted assetId", true);
    options.on === "asset" && !options.aspectname && (0, command_utils_1.errorLog)("you have to specify the targeted aspect name", true);
}
function createTemplate(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const generatedData = (0, command_utils_1.generateTestData)(10, (x) => {
            return 80 + Math.random() * 20 * Math.sin(x);
        }, "Acceleration", "number");
        const fileName = options.data || "timeseries.data.mdsp.json";
        fs.writeFileSync(fileName, JSON.stringify(generatedData, null, 2));
        console.log(`The time series data was written into ${color(fileName)}.\nRun \n\n\tmc ad --mode train --on data --data ${fileName} --epsilon 50.0 \n\nto create the model.\n`);
    });
}
function trainNewModel(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const anomalyDetectionClient = sdk.GetAnomalyDetectionClient();
        const tenant = sdk.GetTenant();
        const timeOffset = new Date().getTime();
        const on = options.on || "data";
        const epsilon = options.epsilon;
        const clustersize = options.clustersize || 2;
        const algorithm = options.algorithm || "EUCLIDEAN";
        const modelname = options.modelname || `Generated_by_CLI_${tenant}_${timeOffset}`;
        switch (on) {
            case "data":
                // read the data file content
                const filePath = path.resolve(options.data);
                !fs.existsSync(filePath) && (0, command_utils_1.errorLog)(`the metadata file ${filePath} doesn't exist!`, true);
                const filecontent = fs.readFileSync(filePath);
                const filedata = JSON.parse(filecontent.toString());
                const result = (yield (0, utils_1.retry)(options.retry, () => __awaiter(this, void 0, void 0, function* () { return anomalyDetectionClient.PostModel(filedata, epsilon, clustersize, algorithm, modelname); })));
                console.log(`Model with modelid ${color(result.id)} and name ${color(result.name)} was created.`);
                break;
            case "asset":
                const assetid = options.assetid;
                const aspectname = options.aspectname;
                const now = new Date();
                const lastMonth = new Date();
                lastMonth.setDate(lastMonth.getDate() - 7);
                const fromLastMonth = new Date(lastMonth.getUTCFullYear(), lastMonth.getUTCMonth(), lastMonth.getUTCDate());
                const toNow = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
                let from = fromLastMonth;
                try {
                    from = options.from ? new Date(options.from) : fromLastMonth;
                }
                catch (error) { }
                let to = toNow;
                try {
                    to = options.to ? new Date(options.to) : toNow;
                }
                catch (error) { }
                const result_asset = (yield (0, utils_1.retry)(options.retry, () => __awaiter(this, void 0, void 0, function* () {
                    return anomalyDetectionClient.PostModelDirect(epsilon, clustersize, assetid, aspectname, from, to, algorithm, modelname);
                })));
                console.log(`Model with modelid ${color(result_asset.id)} and name ${color(result_asset.name)} was created.`);
            default:
                break;
        }
    });
}
function detectAnomalies(options, sdk) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const anomalyDetectionClient = sdk.GetAnomalyDetectionClient();
        const modelid = options.modelid;
        const on = options.on || "data";
        let result = [];
        switch (on) {
            case "data":
                // read the data file content
                const filePath = path.resolve(options.data);
                !fs.existsSync(filePath) && (0, command_utils_1.errorLog)(`the metadata file ${filePath} doesn't exist!`, true);
                const filecontent = fs.readFileSync(filePath);
                const filedata = JSON.parse(filecontent.toString());
                result = (yield (0, utils_1.retry)(options.retry, () => __awaiter(this, void 0, void 0, function* () { return anomalyDetectionClient.DetectAnomalies(filedata, modelid); })));
                break;
            case "asset":
                const assetid = options.assetid;
                const aspectname = options.aspectname;
                const now = new Date();
                const lastMonth = new Date();
                lastMonth.setDate(lastMonth.getDate() - 7);
                const fromLastMonth = new Date(lastMonth.getUTCFullYear(), lastMonth.getUTCMonth(), lastMonth.getUTCDate());
                const toNow = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
                let from = fromLastMonth;
                try {
                    from = options.from ? new Date(options.from) : fromLastMonth;
                }
                catch (error) { }
                let to = toNow;
                try {
                    to = options.to ? new Date(options.to) : toNow;
                }
                catch (error) { }
                result = (yield (0, utils_1.retry)(options.retry, () => __awaiter(this, void 0, void 0, function* () { return anomalyDetectionClient.DetectAnomaliesDirect(modelid, assetid, aspectname, from, to); })));
            default:
                break;
        }
        console.log(`${color((_a = (result || [])) === null || _a === void 0 ? void 0 : _a.length)} anomalies found.\n`);
        ((_b = (result || [])) === null || _b === void 0 ? void 0 : _b.length) > 0 && printDetectedAnomalies(result, options);
    });
}
function printDetectedAnomalies(anomalies, options) {
    console.log("\nDetected anomalies:");
    console.table(anomalies || [], ["_time", "anomalyExtent"]);
    (0, command_utils_1.verboseLog)(JSON.stringify(anomalies, null, 2), options.verbose);
}
//# sourceMappingURL=anomaly-detection.js.map