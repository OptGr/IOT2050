"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalValidationClient = void 0;
const utils_1 = require("../../utils");
const sdk_client_1 = require("../common/sdk-client");
/**
 *
 * ! The following services are intended to be used on small ranges of timeseries data.
 *
 * * Range Check
 * Performs range check. Tries to find data going beyond range for given
 * sensor’s values on given interval.
 *
 * * Spike Alert
 * Performs spike detection. Tries to find spikes for given sensor’s values.
 *
 * * Noise Alert
 * Performs noise detection. Tries to find noises for given sensor’s values.
 *
 * * Jump Alert
 * Performs jump detection. Tries to find jumps for given sensor’s values.
 *
 * * Data Gap Analysis
 * Performs data gap analysis. Tries to find gaps for given sensor’s values and
 * tries to interpolate insufficient measurements.
 *
 * * Bias Alert
 * Performs bias detection. Tries to find biases for given sensor’s values.
 *
 * @export
 * @class SignalValidationClient
 * @extends {SdkClient}
 */
class SignalValidationClient extends sdk_client_1.SdkClient {
    constructor() {
        super(...arguments);
        this._baseUrl = "/api/signalvalidation/v3";
    }
    /**
     * * Launches range check task with specific parameters
     *
     * @param {SignalValidationModels.Timeseries} timeseries
     * @param {{
     *             variableName: string;
     *             lowerLimit: number;
     *             upperLimit: number;
     *         }} params
     *
     * @param params.variableName Target variable name. Only this variable will be taken from given timeseries data.
     * @param params.lowerLimit Processing lower limit, should be less than upper limit.
     * @param params.upperLimit Processing upper limit, should be greater than lower limit.
     * @returns {Promise<SignalValidationModels.Range>}
     *
     * @memberOf SignalValidationClient
     */
    DetectRangeViolations(timeseries, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "POST",
                body: timeseries,
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectrangeviolations?${(0, utils_1.toQueryString)(params)}`
            }));
        });
    }
    /**
     * * Launches spike alert task with specific parameters.
     *
     * @param {SignalValidationModels.Timeseries[]} timeseries
     * @param {{
     *             variableName: string;
     *             windowSize: number;
     *         }} params
     *
     * @param params.variableName Target variable name. Only this variable will be taken from given timeseries data.
     * @param params.windowSize The processing windows size, should be positive.
     * @returns {Promise<SignalValidationModels.Spike[]>}
     * @memberOf SignalValidationClient
     */
    DetectSpikes(timeseries, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "POST",
                body: timeseries,
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectspikes?${(0, utils_1.toQueryString)(params)}`
            }));
        });
    }
    /**
     * This endpoint detects noise for the given sensor. Result is the list of events.
     *
     * @param {SignalValidationModels.Timeseries[]} timeseries
     * @param {{
     *             variableName: string;
     *             windowRadius: number;
     *             threshold: number;
     *         }} params
     *
     * @param params.variableName Target variable name. Only this variable will be taken from given timeseries data.
     * @param params.windowRadius Processing window radius, should be positive.
     * @param params.threshold Threshold to consider outlier value as noise.
     * @returns {Promise<SignalValidationModels.Noise[]>}
     *
     * @memberOf SignalValidationClient
     */
    DetectNoise(timeseries, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "POST",
                body: timeseries,
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectnoise?${(0, utils_1.toQueryString)(params)}`
            }));
        });
    }
    /**
     * * Lauches jump alert task with specific parameters.
     *
     * @param {SignalValidationModels.Timeseries[]} timeseries
     * @param {{
     *             variableName: string;
     *             windowSize: number;
     *         }} params
     *
     * @param params.variableName Target variable name. Only this variable will be taken from given timeseries data.
     * @param params.windowSize The value to limit window size. Positive value
     *
     * @returns {Promise<SignalValidationModels.Jump[]>}
     *
     * @memberOf SignalValidationClient
     */
    DetectJumps(timeseries, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "POST",
                body: timeseries,
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectjumps?${(0, utils_1.toQueryString)(params)}`
            }));
        });
    }
    /**
     * * Launches data gap analysis task with specific parameters
     *
     * @param {SignalValidationModels.Timeseries[]} timeseries
     * @param {{
     *             variableName: string;
     *             threshold: number;
     *         }} params
     *
     * @param params.variableName Target variable name. Only this variable will be taken from given timeseries data.
     * @param params.threshold Max inteval in milliseconds between two consecutive points which is not considered a gap.
     *
     * @returns {Promise<SignalValidationModels.DataGap>}
     *
     * @memberOf SignalValidationClient
     */
    DetectGaps(timeseries, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "POST",
                body: timeseries,
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectgaps?${(0, utils_1.toQueryString)(params)}`
            }));
        });
    }
    /**
     *
     * * Launches data gap analysis task with interpolation
     *
     * @param {SignalValidationModels.Timeseries[]} timeseries
     * @param {{
     *             variableName: string;
     *             threshold: number;
     *         }} params
     *
     * @param params.variableName Target variable name. Only this variable will be taken from given timeseries data.
     * @param params.threshold Max inteval in milliseconds between two consecutive points which is not considered a gap.
     *
     * @returns {Promise<SignalValidationModels.DataGapInterpolated>}
     *
     * @memberOf SignalValidationClient
     */
    DetectGapsAndInterpolate(timeseries, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "POST",
                body: timeseries,
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectgapsandinterpolate?${(0, utils_1.toQueryString)(params)}`
            }));
        });
    }
    /**
     * Launches bias alert task with specific parameters.
     *
     * @param {SignalValidationModels.Timeseries[]} timeseries
     * @param {{
     *             variableName: string;
     *             windowSize: number;
     *             threshold: number;
     *             step: number;
     *         }} params
     *
     * @param params.variableName Target variable name. Only this variable will be taken from given timeseries data.
     * @param params.windowSize Processing window size value, should be positive.
     * @param params.threshold Processing threshold value, should be positive.
     * @param params.step Processing step value, should be from 1 to windowSize.
     *
     * @returns {Promise<SignalValidationModels.Bias[]>}
     *
     * @memberOf SignalValidationClient
     */
    DetectBias(timeseries, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "POST",
                body: timeseries,
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectbias?${(0, utils_1.toQueryString)(params)}`
            }));
        });
    }
}
exports.SignalValidationClient = SignalValidationClient;
//# sourceMappingURL=signal-validation.js.map