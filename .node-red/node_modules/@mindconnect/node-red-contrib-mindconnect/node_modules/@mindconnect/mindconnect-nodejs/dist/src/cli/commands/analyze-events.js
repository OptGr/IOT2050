"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const fs = require("fs");
const lodash_1 = require("lodash");
const path = require("path");
const utils_1 = require("../../api/utils");
const command_utils_1 = require("./command-utils");
let color = (0, command_utils_1.getColor)("blue");
exports.default = (program) => {
    program
        .command("event-analytics")
        .alias("ea")
        .option("-m, --mode [count|filter|duplicate|top]", `mode see ${color("@ Additional Documentation")}`, "top")
        .option("-f, --file <file>", `events file`)
        .option("-o, --output <output>", `result ${color("mode")}.ea.mdsp.json`)
        .option("-t, --type [timeseries|event]", `event analytics can be used on both timeseries (with string properties as event names) and event formats`, "event")
        .option("-p, --property <property>", `property name used for grouping and counting`, "description")
        .option("-l, --filterlist <filterlist>", `filter events`, "[]")
        .option("-x, --top <top>", "number of events (for top mode)", "10")
        .option("-s, --split <split>", "split interval (for count, duplicate)", "5000")
        .option("-y, --retry <number>", "retry attempts before giving up", "3")
        .option("-p, --passkey <passkey>", `passkey`)
        .option("-v, --verbose", "verbose output")
        .description(`${color("analyze mindsphere events @")}`)
        .action((options) => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                checkRequiredParameters(options);
                const sdk = (0, command_utils_1.getSdk)(options);
                color = (0, command_utils_1.adjustColor)(color, options, true);
                (0, command_utils_1.homeDirLog)(options.verbose, color);
                (0, command_utils_1.proxyLog)(options.verbose, color);
                const fileName = path.resolve(options.file);
                const data = fs.readFileSync(fileName).toString();
                const events = JSON.parse(data);
                let newEvents = events;
                if (options.type === "event") {
                    newEvents = [];
                    events.events.forEach((element) => {
                        const newObject = { _time: element.timestamp };
                        newObject[options.property] = element[options.property];
                        newEvents.push(newObject);
                    });
                }
                const ea = sdk.GetEventAnalyticsClient();
                const output = options.output || `${options.mode}.ea.mdsp.json`;
                switch (options.mode) {
                    case "top":
                        yield getTopEvents(ea, options, newEvents, output);
                        break;
                    case "count":
                        yield countEvents(ea, options, newEvents, output);
                        break;
                    case "duplicate":
                        yield removeDuplicates(ea, options, newEvents, output);
                        break;
                    case "filter":
                        yield filterEvents(ea, options, newEvents, output);
                        break;
                    default:
                        throw Error(`no such option: ${options.mode}`);
                }
            }
            catch (err) {
                (0, command_utils_1.errorLog)(err, options.verbose);
            }
        }))();
    })
        .on("--help", () => {
        (0, console_1.log)("\n  Examples:\n");
        (0, console_1.log)(`    mc event-analytics --mode top --file events.json --property description \t\t find the top 10 events in events.json`);
        (0, console_1.log)(`    mc event-analytics --mode duplicate --file events.json --property description --split 5000 \t\t remove all duplicate events`);
        (0, console_1.log)("\n  Additional Documentation:\n");
        (0, console_1.log)(`    ${color("https://developer.mindsphere.io/apis/analytics-eventanalytics/api-eventanalytics-overview.html")}`);
        (0, console_1.log)(`    ${color("https://developer.mindsphere.io/apis/analytics-eventanalytics/api-eventanalytics-samples.html")}`);
        (0, command_utils_1.serviceCredentialLog)(color);
    });
};
function getTopEvents(ea, options, newEvents, output) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield (0, utils_1.retry)(options.retry, () => ea.FindTopEvents({
            numberOfTopPositionsRequired: parseInt(options.top),
            eventsMetadata: { eventTextPropertyName: options.property },
            events: newEvents,
        }));
        fs.writeFileSync(output, JSON.stringify(result, null, 2));
        (0, command_utils_1.verboseLog)(JSON.stringify(result, null, 2), options.verbose);
        console.log(`wrote results to ${color(output)}`);
    });
}
function countEvents(ea, options, newEvents, output) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield (0, utils_1.retry)(options.retry, () => ea.CountEvents({
            eventsMetadata: {
                eventTextPropertyName: options.property,
                splitInterval: parseInt(options.split),
            },
            events: newEvents,
        }));
        fs.writeFileSync(output, JSON.stringify(result, null, 2));
        (0, command_utils_1.verboseLog)(JSON.stringify(result, null, 2), options.verbose);
        console.log(`wrote results to ${color(output)}`);
    });
}
function removeDuplicates(ea, options, newEvents, output) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield (0, utils_1.retry)(options.retry, () => ea.RemoveDuplicateEvents({
            eventsMetadata: {
                eventTextPropertyName: options.property,
                splitInterval: parseInt(options.split),
            },
            events: newEvents,
        }));
        fs.writeFileSync(output, JSON.stringify(result, null, 2));
        (0, command_utils_1.verboseLog)(JSON.stringify(result, null, 2), options.verbose);
        console.log(`wrote results to ${color(output)}`);
    });
}
function filterEvents(ea, options, newEvents, output) {
    return __awaiter(this, void 0, void 0, function* () {
        const resultFilter = yield (0, utils_1.retry)(options.retry, () => ea.FilterEvents({
            eventsMetadata: {
                eventTextPropertyName: options.property,
            },
            events: newEvents,
            filterList: options.filterlist ? JSON.parse(options.filterlist) : [],
        }));
        fs.writeFileSync(output, JSON.stringify(resultFilter, null, 2));
        (0, command_utils_1.verboseLog)(JSON.stringify(resultFilter, null, 2), options.verbose);
        console.log(`wrote results to ${color(output)}`);
    });
}
function checkRequiredParameters(options) {
    !["timeseries", "event"].includes(options.type) &&
        (0, command_utils_1.errorLog)(`invalid type ${options.type}; type must be timeseries or event`, true);
    !options.file && (0, command_utils_1.errorLog)(`you have to specify the file name in the --file option`, true);
    if (options.filterlist) {
        try {
            const obj = JSON.parse(options.filterlist);
            if (!(0, lodash_1.isArray)(obj)) {
                (0, command_utils_1.errorLog)("invalid filter, you have to pass an array with event names. example --filterlist '[\"Flow to low\"]' ", true);
            }
        }
        catch (error) {
            (0, command_utils_1.errorLog)("invalid filter, you have to pass an array with event names. example --filterlist '[\"Flow to low\"]' ", true);
        }
    }
}
//# sourceMappingURL=analyze-events.js.map