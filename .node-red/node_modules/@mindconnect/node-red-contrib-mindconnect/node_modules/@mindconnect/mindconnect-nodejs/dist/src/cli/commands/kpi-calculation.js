"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const fs = require("fs");
const path = require("path");
const utils_1 = require("../../api/utils");
const command_utils_1 = require("./command-utils");
const _ = require("lodash");
let color = (0, command_utils_1.getColor)("blue");
exports.default = (program) => {
    program
        .command("kpi-calculation")
        .alias("kp")
        .option("-f, --file <timeseries>", `timeseries file`, `timeseries-sample.json`)
        .option("-c, --calendar <calendar>", `timeseries with planned outages`)
        .option("-e, --events <events>", `timeseries with control system events`)
        .option("-m, --mode [direct|states|kpis]", `mode see ${color("@ Additional Documentation")}`)
        .option("-t, --target <target>", `target variable`)
        .option("-f, --from <from>", "timeseries begin  (used for direct state calculation)")
        .option("-o, --to <to>", "timeseries end  (used for direct state calculation)")
        .option("-i, --assetid <assetid>", "Asset id  (used for direct state calculation)")
        .option("-a, --aspectname <aspectname>", "Aspect name (used for direct state calculation )")
        .option("-n, --initialstate <initialstate>", "Initial state [RSH, SH, POH, FOH]", "RSH")
        .option("-d, --defaultstate <defaultstate>", "Default state [RSH, FOH]", "FOH")
        .option("-h, --threshold <threshold>", `threshold parameter`, "1.0")
        .option("-s, --shutdown <shutdown>", `shutdown threshold parameter in milliseconds`, "5000")
        .option("-y, --retry <number>", "retry attempts before giving up", "3")
        .option("-p, --passkey <passkey>", `passkey`)
        .option("-v, --verbose", "verbose output")
        .description(`${color("calculate kpi states or compute kpis @")}`)
        .action((options) => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                checkParameters(options);
                const sdk = (0, command_utils_1.getSdk)(options);
                color = (0, command_utils_1.adjustColor)(color, options, true);
                (0, command_utils_1.homeDirLog)(options.verbose, color);
                (0, command_utils_1.proxyLog)(options.verbose, color);
                const kpiClient = sdk.GetKPICalculationClient();
                switch (options.mode) {
                    case "direct":
                        {
                            (0, command_utils_1.verboseLog)(`calculating KPI states for target variable: ${options.input} using data stored in mindsphere`, options.verbose);
                            const from = new Date(options.from);
                            const to = new Date(options.to);
                            (0, command_utils_1.verboseLog)(`timeseries begin: ${from.toISOString()} timeseries end: ${to.toISOString()}`, options.verbose);
                            const calendar = options.calendar
                                ? readDataFromFile(options.calendar, options.verbose)
                                : { plannedOutage: [] };
                            const events = options.events ? readDataFromFile(options.events, options.verbose) : [];
                            const results = yield (0, utils_1.retry)(options.retry, () => kpiClient.CalculateKpiStatesDirect({
                                calendar: calendar,
                                ControlSystemEvents: events,
                            }, {
                                from: from,
                                to: to,
                                variableName: options.target,
                                initialState: options.initialstate,
                                defaultState: options.defaultstate,
                                assetId: options.assetid,
                                aspectName: options.aspectname,
                                threshold: options.threshold,
                                shutdownCorrelationThreshold: options.shutdown,
                            }));
                            // create timeseries from kpi state indications
                            const ts = _.map(results.indications, (item) => {
                                return { _time: item.timestamp, state: item.state, source: item.source };
                            });
                            console.log(JSON.stringify(ts, null, 2));
                        }
                        break;
                    case "states":
                        {
                            (0, command_utils_1.verboseLog)(`calculating kpi state for target variable: ${options.input}`, options.verbose);
                            const timeSeries = readDataFromFile(options.file, options.verbose);
                            const from = new Date(_.minBy(timeSeries, "_time")["_time"]);
                            const to = new Date(_.maxBy(timeSeries, "_time")["_time"]);
                            const calendar = options.calendar
                                ? readDataFromFile(options.calendar, options.verbose)
                                : { plannedOutage: [] };
                            const events = options.events ? readDataFromFile(options.events, options.verbose) : [];
                            const results = yield (0, utils_1.retry)(options.retry, () => kpiClient.CaclulateKpiStates({
                                calendar: calendar,
                                timeseries: timeSeries,
                                ControlSystemEvents: events,
                            }, {
                                from: from,
                                to: to,
                                variableName: options.target,
                                initialState: options.initialstate,
                                defaultState: options.defaultstate,
                                threshold: options.threshold,
                                shutdownCorrelationThreshold: options.shutdown,
                            }));
                            // create timeseries from kpi state indications
                            const ts = _.map(results.indications, (item) => {
                                return { _time: item.timestamp, state: item.state, source: item.source };
                            });
                            console.log(JSON.stringify(ts, null, 2));
                        }
                        break;
                    case "kpis":
                        {
                            const timeSeries = readDataFromFile(options.file, options.verbose);
                            const from = new Date(_.minBy(timeSeries, "_time")["_time"]);
                            const to = new Date(_.maxBy(timeSeries, "_time")["_time"]);
                            const results = yield (0, utils_1.retry)(options.retry, () => kpiClient.ComputeKPI(timeSeries, {
                                from: from,
                                to: to,
                                variableName: options.target,
                                initialState: options.initialstate,
                            }));
                            console.log(JSON.stringify(results, null, 2));
                        }
                        break;
                }
            }
            catch (err) {
                (0, command_utils_1.errorLog)(err, options.verbose);
            }
        }))();
    })
        .on("--help", () => {
        (0, console_1.log)("\n  Examples:\n");
        (0, console_1.log)(`    mc kpi-calculation --mode states --file timeseries.mdsp.json --calendar calendar.mdsp.json  --target rpm --threshold 30 \n \t\tcalculate kpi states based on rpm`);
        (0, console_1.log)(`    mc kpi-calculation --mode direct --target rpm --assetid 123...ef --aspectname EngineParameters  --from <date> --to <date> \n \t\tcalculate kpi states based on asset data in MindSphere`);
        (0, console_1.log)(`    mc kpi-calculation --mode kpis --file states.mdsp.json --target state \n \t\tcalculate kpis for state timeseries`);
        (0, console_1.log)("\n  State KPIs:\n");
        (0, console_1.log)(`    No Data Hours ${color("(NoData)")}, Period Hours ${color("(PH)")}, Available Hours ${color("(AH)")} Service Hours ${color("(SH)")} `);
        (0, console_1.log)(`    Reserve Shutdown Hours ${color("(RSH)")}, Unavailble Hours ${color("(UH)")}, Planned Outage Hours ${color("(POH)")} Forced Outage Hours ${color("(FOH)")} `);
        (0, console_1.log)("\n  Additional Documentation:\n");
        (0, console_1.log)(`    ${color("https://developer.mindsphere.io/apis/analytics-kpicalculation/api-kpicalculation-basics-kpi.html")}`);
        (0, console_1.log)("\n  Example Jupyter Notebook:\n");
        (0, console_1.log)(`    ${color("https://github.com/mindsphere/analytics-examples/blob/master/kpi-calculation.ipynb")}`);
        (0, command_utils_1.serviceCredentialLog)(color);
    });
};
function readDataFromFile(filename, verbose) {
    const timeSeriesDataFile = path.resolve(filename);
    (0, command_utils_1.verboseLog)(`reading data from ${timeSeriesDataFile}`, verbose);
    const buffer = fs.readFileSync(timeSeriesDataFile);
    const data = JSON.parse(buffer.toString());
    return data;
}
function checkParameters(options) {
    !options.mode &&
        (0, command_utils_1.errorLog)("You have to provide the mode for the command. Run mc kp --help for full syntax and examples.", true);
    options.mode !== "direct" &&
        !options.file &&
        (0, command_utils_1.errorLog)("You have to provide at least the file with timeseries data", true);
    options.mode === "direct" &&
        (!options.assetid || !options.aspectname || !options.from || !options.to) &&
        (0, command_utils_1.errorLog)("You have to provide asssetid, aspectname, from and to for the direct kpi states calculation mode", true);
    !options.target && (0, command_utils_1.errorLog)("You have to provide the target variable", true);
    !options.initialstate && (0, command_utils_1.errorLog)("You have to provide the initital state", true);
    options.mode === "states" &&
        !options.defaultstate &&
        (0, command_utils_1.errorLog)("You have to provide the default state for kpi states calculation", true);
    options.mode === "states" &&
        !options.threshold &&
        (0, command_utils_1.errorLog)("You have to provide the threshold for kpi states calculation", true);
    options.mode === "states" &&
        !options.shutdown &&
        (0, command_utils_1.errorLog)("You have to provide the shutdown correlation threshold in miliseconds for kpi states calculation", true);
    !["states", "kpis", "direct"].includes(options.mode) &&
        (0, command_utils_1.errorLog)(`the mode must be either one of: states or kpis`, true);
}
//# sourceMappingURL=kpi-calculation.js.map