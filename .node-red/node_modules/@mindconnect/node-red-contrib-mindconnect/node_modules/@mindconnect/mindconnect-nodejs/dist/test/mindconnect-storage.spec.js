"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (C), Siemens AG 2017
const chai = require("chai");
require("url-search-params-polyfill");
const src_1 = require("../src");
const test_utils_1 = require("./test-utils");
const rimraf = require("rimraf");
const _ = require("lodash");
chai.should();
describe("Default Storage", () => {
    const rsaConfig = require("./testconfig.json");
    process.env.DEBUG = "mindconnect-storage";
    it("should instantiate. @s4f", (0, test_utils_1.mochaAsync)(() => __awaiter(void 0, void 0, void 0, function* () {
        const storage = new src_1.DefaultStorage("./.mochatest/");
        storage.should.not.be.null;
        rimraf.sync("./.mochatest/");
    })));
    it("should be able to read configuration @s4f", (0, test_utils_1.mochaAsync)(() => __awaiter(void 0, void 0, void 0, function* () {
        const storage = new src_1.DefaultStorage("./.mochatest/");
        const config = yield storage.GetConfig(rsaConfig);
        config.should.not.be.null;
        _.isEqual(rsaConfig, config).should.be.true;
        rimraf.sync("./.mochatest/");
    })));
    it("should be able to save configuration @s4f", (0, test_utils_1.mochaAsync)(() => __awaiter(void 0, void 0, void 0, function* () {
        const storage = new src_1.DefaultStorage("./.mochatest/");
        rsaConfig.urls = ["TEST"];
        const config = yield storage.SaveConfig(rsaConfig);
        config.should.not.be.null;
        _.isEqual(rsaConfig, config).should.be.true;
        config.urls.should.not.be.undefined;
        config.urls[0].should.equal("TEST");
        const newConfig = yield storage.GetConfig(rsaConfig);
        _.isEqual(config, newConfig).should.be.true;
        newConfig.urls.should.not.be.undefined;
        newConfig.urls[0].should.equal("TEST");
        rimraf.sync("./.mochatest/");
    })));
    it("should be able to revert configuration if content changes @s4f", (0, test_utils_1.mochaAsync)(() => __awaiter(void 0, void 0, void 0, function* () {
        const storage = new src_1.DefaultStorage("./.mochatest/");
        rsaConfig.urls = ["TEST"];
        const config = yield storage.SaveConfig(rsaConfig);
        config.should.not.be.null;
        _.isEqual(rsaConfig, config).should.be.true;
        config.urls.should.not.be.undefined;
        config.urls[0].should.equal("TEST");
        const newConfig = yield storage.GetConfig(rsaConfig);
        _.isEqual(config, newConfig).should.be.true;
        newConfig.urls.should.not.be.undefined;
        newConfig.urls[0].should.equal("TEST");
        rsaConfig.content.clientCredentialProfile = ["SHARED_SECRET"];
        delete rsaConfig.urls;
        const revertedConfig = yield storage.GetConfig(rsaConfig);
        (revertedConfig.urls === undefined).should.be.true;
        rimraf.sync("./.mochatest/");
    })));
    it("should be able to syncronize the locks @s4f", (0, test_utils_1.mochaAsync)(() => __awaiter(void 0, void 0, void 0, function* () {
        const storage = new src_1.DefaultStorage("./.mochatest/");
        rsaConfig.urls = ["TEST"];
        const promises = [];
        rsaConfig.indexes = [];
        for (let index = 0; index < 25; index++) {
            rsaConfig.indexes.push(index);
            promises.push(yield (0, src_1.retry)(5, () => storage.SaveConfig(rsaConfig)));
        }
        yield Promise.all(promises);
        const newConfig = storage.GetConfig(rsaConfig);
        for (let index = 0; index < newConfig.indexes.length; index++) {
            const element = rsaConfig.indexes[index];
            index.should.be.equal(element);
        }
        rimraf.sync("./.mochatest/");
    })));
});
//# sourceMappingURL=mindconnect-storage.spec.js.map