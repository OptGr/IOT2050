"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JobManagerClient = void 0;
const utils_1 = require("../../utils");
const sdk_client_1 = require("../common/sdk-client");
/**
 * Offers execution mechanisms for running models stored in Model Management module.
 * A schedule is created based on a model identifier and a cron expression so the model will run one or multiple times.
 * Each time a model runs a new job is generated.
 * When the schedule is created it will start according to the cron expression.
 * If a user wants to stop the executions it can update the status of the schedule and the executions will stop.
 * Also the user has the possibility to update again the status and trigger again the schedule.
 * If a user does not want to run a model multiple times or based on a schedule expression
 * it can start immediately a new job.
 *
 * @export
 * @class JobManagerClient
 * @extends {SdkClient}
 */
class JobManagerClient extends sdk_client_1.SdkClient {
    constructor() {
        super(...arguments);
        this._baseUrl = "/api/jobmanager/v3";
    }
    /**
     * * Jobs
     *
     * Retrieves all the job executions within a tenant, sorted by creationDate descendant order,
     * up to 10.000 items, paged, maximum 100 items per request if no paging parameters are specified.
     * The service purges all jobs older than 90 days that have one of the final statuses
     * (e.g. STOPPED, FAILED, SUCCEEDED).
     *
     * @param {{
     *         pageNumber?: number;
     *         pageSize?: number;
     *         filter?: string;
     *     }} [params]
     * @returns {Promise<JobManagerModels.JobList>}
     *
     * @example Filter example:
     * {"message": {"contains": "Error"},"status": { "or": {{"eq" : "STOPPED"},{"eq" : "FAILED"}}},"creationDate":
     * {{"after": "2018-06-23T20:09:00"}}}
     * @memberOf JobManagerClient
     */
    GetJobs(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const parameters = params || {};
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/jobs?${(0, utils_1.toQueryString)(parameters)}`,
            });
            return result;
        });
    }
    /**
     * * Jobs
     *
     * Creates a new job execution based on the model identifier.
     * This endpoint offers the possibility of running a model or an algorithms
     * just one time without the need of providing a schedule string
     * The inputFolderId and outputFolderId are identifiers of data sources provided by
     * Data Exchange module.
     *
     * @param {JobManagerModels.JobParameters} parameter
     * @returns {Promise<JobManagerModels.Job>}
     *
     * @memberOf JobManagerClient
     */
    PostJob(parameter) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                body: parameter,
                baseUrl: `${this._baseUrl}/jobs`,
            });
            return result;
        });
    }
    /**
     *
     * * Jobs
     *
     * Retrieves the details regarding a job execution
     *
     * @param {string} id
     * @returns {Promise<JobManagerModels.Job>}
     *
     * @memberOf JobManagerClient
     */
    GetJob(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/jobs/${id}`,
            });
            return result;
        });
    }
    /**
     *
     * * Jobs
     *
     * Stops a job execution. The call sets the job's status to STOPPING,
     * while letting the service to internally handle the additional
     * steps required to get the job into a STOPPED status.
     * Caller is responsible for polling the status until the job has reached
     * a final state. In the event that the stop action fails for various
     * reasons, the job execution can end up with a FAILED status.
     * Existing results that were resulted from execution will be kept and
     * provided to Data Exchange following the parameters used to start the
     * job execution. If no output parameters were defined, any definitive
     * (or partial) results will be lost and cleaned up during the stopping process.
     *
     * @param {string} id
     * @returns {Promise<JobManagerModels.Job>}
     *
     * @memberOf JobManagerClient
     */
    StopJob(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/jobs/${id}/stop`,
            });
            return result;
        });
    }
    /**
     * * Schedules
     *
     * Retrieves a list with all schedules stored within the same tenant
     *
     * @param {{
     *         pageNumber?: number;
     *         pageSize?: number;
     *         filter?: string;
     *     }} [params]
     * @returns {Promise<JobManagerModels.ScheduleList>}
     * @example Schedule Filter
     *
     * Complex and flexible filter that can filter by creationDate, name, status, modelId and scheduleString.
     * All the top fields used in the filter are ANDed, but the searched values can use AND and OR operands, including comparison operators where the values allow. All fields are optional.
     * The expected filter format is:
     * ?filter={
     * "status": {
     * "eq": "RUNNING"
     * },"message": {
     * "eq": "Insufficient disk space"
     * },"creationDate": {
     * "gt": "2018-06-23T20:09:00"
     * },
     * "name": {
     * "eq": "Every 2 Months"
     * }
     * }
     *
     * @memberOf JobManagerClient
     */
    GetSchedules(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const parameters = params || {};
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/schedules?${(0, utils_1.toQueryString)(parameters)}`,
                body: {},
                additionalHeaders: { "Content-Type": "application/json" }, // ! fix:  April 2021 manual fix for the schedules endpoint
            });
            return result;
        });
    }
    /**
     * * Schedules
     *
     * Schedules a job for execution specified by its model id and a schedule string.
     * The model ID is retrieved from Model Management module after uploading a model.
     * The schedule string follows the cron format. Example 0 15 10 * * ? - will trigger the model at 10:15 am every day
     *
     * @param {JobManagerModels.ScheduleParameters} parameters
     * @returns {Promise<JobManagerModels.ScheduleDetails>}
     *
     * @memberOf JobManagerClient
     */
    PostSchedule(parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                body: parameters,
                baseUrl: `${this._baseUrl}/schedules`,
            });
            return result;
        });
    }
    /**
     * * Schedules
     *
     * Retrieves information about a schedule
     *
     * @param {string} id
     * @returns {Promise<JobManagerModels.ScheduleDetails>}
     *
     * @memberOf JobManagerClient
     */
    GetSchedule(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/schedules/${id}`,
            });
            return result;
        });
    }
    /**
     * * Schedules
     *
     * Removes a schedule
     *
     * This endpoint offers the possibility of removing a schedule from the storage
     *
     * @param {string} id
     *
     * @memberOf JobManagerClient
     */
    DeleteSchedule(id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.HttpAction({
                verb: "DELETE",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/schedules/${id}`,
                noResponse: true,
            });
        });
    }
    /**
     *
     * * Jobs
     *
     * Updates the status of the schedule to started.
     * If a schedule has been stopped it can be started again using this endpoint.
     * If a schedule is running, based on the schedule string it creates jobs
     *
     * @param {string} id
     * @returns {Promise<JobManagerModels.ScheduleDetails>}
     *
     * @memberOf JobManagerClient
     */
    StartSchedule(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/schedules/${id}/start`,
            });
            return result;
        });
    }
    /**
     * * Schedules
     *
     * Updates the status of the schedule to stopped.
     * If a user wants to stop a schedule this endpoint offers the possibility to update the status
     * of the schedule to stop. When a scheduler is stopped it cannot create new jobs executions
     *
     * @param {string} id
     * @returns {Promise<JobManagerModels.ScheduleDetails>}
     *
     * @memberOf JobManagerClient
     */
    StopSchedule(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/schedules/${id}/stop`,
            });
            return result;
        });
    }
}
exports.JobManagerClient = JobManagerClient;
//# sourceMappingURL=jobmanager.js.map