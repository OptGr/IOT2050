"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (C), Siemens AG 2017
const chai = require("chai");
const debug = require("debug");
const mocha_1 = require("mocha");
const nock = require("nock");
require("url-search-params-polyfill");
const src_1 = require("../src");
const sdk_1 = require("../src/api/sdk/");
const utils_1 = require("../src/api/utils");
const test_agent_setup_utils_1 = require("./test-agent-setup-utils");
const test_utils_1 = require("./test-utils");
const log = debug("mindconnect-agent-auth");
chai.should();
describe("Agent Auth Rotation", () => {
    const auth = (0, utils_1.loadAuth)();
    const sdk = new sdk_1.MindSphereSdk(Object.assign(Object.assign({}, auth), { basicAuth: (0, utils_1.decrypt)(auth, (0, test_utils_1.getPasskeyForUnitTest)()) }));
    let agentConfig = {};
    let unitTestConfiguration = {};
    const southgateUrl = sdk.GetGateway().replace("gateway", "southgate");
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        nock.cleanAll();
        unitTestConfiguration = yield (0, test_agent_setup_utils_1.unitTestSetup)(sdk, sdk_1.AgentManagementModels.AgentUpdate.SecurityProfileEnum.SHAREDSECRET);
        agentConfig = unitTestConfiguration.agentConfig;
    }));
    after(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, test_agent_setup_utils_1.tearDownAgents)(sdk, unitTestConfiguration);
    }));
    (0, mocha_1.it)("should use correct url @sanity", () => __awaiter(void 0, void 0, void 0, function* () {
        southgateUrl.should.contain("southgate");
    }));
    (0, mocha_1.it)("onboarding should be able to handle internet connection problems @sanity", () => __awaiter(void 0, void 0, void 0, function* () {
        // respond 3 times with internal server error before returning the correct response
        const scope = nock(`${southgateUrl}:443`, {
            encodedQueryParams: true,
            allowUnmocked: true,
        })
            .post("/api/agentmanagement/v3/register", {})
            .thrice()
            .reply(500, "Internal Server Error");
        const agent = new src_1.MindConnectAgent(agentConfig);
        agent.should.not.be.undefined;
        // try 8 times so that we can be sure that the agent will get onboarded
        const result = yield (0, utils_1.retry)(8, () => agent.OnBoard());
        result.should.be.equal(src_1.OnboardingStatus.StatusEnum.ONBOARDED);
        scope.done();
    }));
    (0, mocha_1.it)("should be able to recover from a problem with key rotation.", () => __awaiter(void 0, void 0, void 0, function* () {
        const agent = new src_1.MindConnectAgent(agentConfig);
        agent.should.not.be.undefined;
        nock.cleanAll();
        if (!agent.IsOnBoarded())
            yield (0, utils_1.retry)(5, () => agent.OnBoard());
        const responseA = JSON.stringify(agent._configuration.response);
        yield agent.RotateKey();
        agent._configuration.response = JSON.parse(responseA);
        yield agent.RotateKey();
        const responseB = JSON.stringify(agent._configuration.response);
        agent._configuration.response = JSON.parse(responseA);
        yield agent.RotateKey();
        yield agent.AquireToken();
        yield agent.AquireToken();
        yield agent.RenewToken();
        agent._configuration.response = JSON.parse(responseB);
        const errorShouldOccur = yield (0, test_utils_1.errorHelper)(() => agent.RotateKey());
        errorShouldOccur.should.be.true;
        yield agent.RenewToken();
    }));
    (0, mocha_1.it)("should be able to store old keys", () => __awaiter(void 0, void 0, void 0, function* () {
        const agent = new src_1.MindConnectAgent(agentConfig);
        agent.should.not.be.undefined;
        nock.cleanAll();
        if (!agent.IsOnBoarded())
            yield (0, utils_1.retry)(5, () => agent.OnBoard());
        yield agent.RotateKey();
        yield agent.RotateKey();
        yield agent.RotateKey();
        yield agent.RotateKey();
        yield agent.RotateKey();
        agent._configuration.recovery.length.should.be.equal(5);
        yield agent.RotateKey();
        agent._configuration.recovery.length.should.be.equal(5);
    }));
    (0, mocha_1.it)("should be able to handle errors in key rotation", () => __awaiter(void 0, void 0, void 0, function* () {
        const agent = new src_1.MindConnectAgent(agentConfig);
        agent.should.not.be.undefined;
        nock.cleanAll();
        if (!agent.IsOnBoarded())
            yield (0, utils_1.retry)(5, () => agent.OnBoard());
        yield (0, utils_1.retry)(3, () => agent.RotateKey());
        yield (0, utils_1.retry)(3, () => agent.RenewToken());
        agent._configuration.recovery.length.should.be.greaterThan(1);
        const scope = nock(`${southgateUrl}:443`, {
            encodedQueryParams: true,
            allowUnmocked: true,
        })
            .put(`/api/agentmanagement/v3/register/${agent.ClientId()}`, {
            client_id: `${agent.ClientId()}`,
        })
            .times(24)
            .reply(500, "Internal Server error");
        const today = new Date();
        const inOneHour = new Date(today);
        inOneHour.setHours(today.getHours() + 1);
        agent._configuration.response.client_secret_expires_at = Math.trunc(inOneHour.getTime() / 1000);
        agent._configuration.response.client_secret = "broken";
        agent._configuration.response.registration_access_token = "broken";
        yield agent.RenewToken();
        yield agent.RenewToken();
        yield agent.RenewToken();
        scope.done();
        nock.cleanAll();
        agent._accessToken = undefined;
        const token = yield agent.GetAgentToken();
        token.should.not.be.undefined;
        token.should.not.be.null;
        token.should.not.be.equal("");
        scope.done();
    }));
    (0, mocha_1.it)("should handle problems with certificate urls", () => __awaiter(void 0, void 0, void 0, function* () {
        const agent = new src_1.MindConnectAgent(agentConfig);
        agent.should.not.be.undefined;
        nock.cleanAll();
        if (!agent.IsOnBoarded())
            yield (0, utils_1.retry)(5, () => agent.OnBoard());
        const scope = nock(`${southgateUrl}:443`, {
            encodedQueryParams: true,
            allowUnmocked: true,
        })
            .get(`/api/agentmanagement/v3/oauth/token_key`)
            .times(4)
            .reply(500, "Internal Server error");
        yield (0, utils_1.retry)(2, () => agent.RenewToken());
        const token = yield agent.GetAgentToken();
        token.should.not.be.undefined;
        token.length.should.be.greaterThan(10);
        scope.done();
    }));
});
//# sourceMappingURL=agent-auth.spec.js.map