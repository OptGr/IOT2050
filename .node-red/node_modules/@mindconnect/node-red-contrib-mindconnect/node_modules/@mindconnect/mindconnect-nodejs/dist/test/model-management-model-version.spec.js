"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
require("url-search-params-polyfill");
const sdk_1 = require("../src/api/sdk");
const utils_1 = require("../src/api/utils");
const test_utils_1 = require("./test-utils");
chai.should();
const timeOffset = new Date().getTime();
const futureTimeOffset = new Date(timeOffset + 1000 * 60 * 60 * 24);
describe("[SDK] ModelManagementClient.Models.Version", () => {
    const auth = (0, utils_1.loadAuth)();
    const sdk = new sdk_1.MindSphereSdk(Object.assign(Object.assign({}, auth), { basicAuth: (0, utils_1.decrypt)(auth, (0, test_utils_1.getPasskeyForUnitTest)()) }));
    const modelManagement = sdk.GetModelManagementClient();
    let mmModelId = "";
    const testModelDefinition = {
        name: "NN - Quasi Newton",
        description: "[Version] Newton using variable metrix methods",
        type: "Zeppelin notebook",
        lastVersion: {
            number: 1.0,
            expirationDate: "2099-10-01T12:00:00.001",
            dependencies: [
                {
                    name: "sklearn-theano",
                    type: "Python",
                    version: "2.7",
                },
            ],
            io: {
                consumes: "CSV",
                input: [
                    {
                        name: "variablename1",
                        type: "integer",
                        description: "description for variablename1",
                        value: 5,
                    },
                ],
                output: [
                    {
                        name: "outputname1",
                        type: "integer",
                        description: "description for outputname1",
                        value: 1,
                    },
                ],
                optionalParameters: {
                    freeFormParams: "for the author to use",
                    param1: "value1",
                },
            },
            kpi: [
                {
                    name: "error rate",
                    value: "0.9",
                },
            ],
        },
    };
    const testModelVersionDefinition = {
        number: 2.0,
        expirationDate: "2021-10-01T12:00:00.001",
        dependencies: [
            {
                name: "sklearn-theano",
                type: "Python",
                version: "2.7",
            },
        ],
        io: {
            consumes: "CSV",
            input: [
                {
                    name: "variablename1",
                    type: "integer",
                    description: "description for variablename1",
                    value: 0,
                },
            ],
            output: [
                {
                    name: "outputname1",
                    type: "integer",
                    description: "description for outputname1",
                    value: 0,
                },
            ],
            optionalParameters: {
                freeFormParams: "for the author to use",
                param1: "value1",
            },
        },
        kpi: [
            {
                name: "error rate",
                value: "0.9",
            },
            {
                name: "mse",
                value: "0.01",
            },
        ],
    };
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        yield deleteModels(modelManagement);
        testModelDefinition.name = `xyz_${timeOffset}_mm_A`;
        const result = yield modelManagement.PostModel(testModelDefinition, {
            buffer: Buffer.from("xyz"),
            fileName: `xyz${timeOffset}_mm_A.txt`,
            mimeType: "text/plain",
        });
        mmModelId = `${result.id}`;
    }));
    after(() => __awaiter(void 0, void 0, void 0, function* () {
        yield deleteModels(modelManagement);
    }));
    it("SDK should not be undefined", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
    }));
    it("standard properties shoud be defined", () => __awaiter(void 0, void 0, void 0, function* () {
        modelManagement.should.not.be.undefined;
        modelManagement.GetGateway().should.be.equal(auth.gateway);
        (yield modelManagement.GetToken()).length.should.be.greaterThan(200);
        (yield modelManagement.GetToken()).length.should.be.greaterThan(200);
    }));
    it("should GET the last version of a model @sanity", () => __awaiter(void 0, void 0, void 0, function* () {
        modelManagement.should.not.be.undefined;
        const oVersion = yield modelManagement.GetModelLastVersion(`${mmModelId}`);
        oVersion.should.not.be.undefined;
        oVersion.should.not.be.null;
        oVersion.number.should.be.equals(`${1.0}`);
    }));
    it("should GET all versions of a model", () => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        modelManagement.should.not.be.undefined;
        testModelDefinition.name = `xyz_${timeOffset}_mm_version_A`;
        const model = yield modelManagement.PostModel(testModelDefinition, {
            buffer: Buffer.from("xyz"),
            fileName: `xyz${timeOffset}_mm_version_A.txt`,
            mimeType: "text/plain",
        });
        model.should.not.be.undefined;
        model.should.not.be.null;
        const versions = yield modelManagement.GetModelVersions({
            modelId: `${model.id}`,
            pageNumber: 0,
            pageSize: 100,
        });
        versions.should.not.be.undefined;
        versions.should.not.be.null;
        versions.page.number.should.equal(0);
        versions.page.size.should.be.equal(1);
        (_a = versions.versions) === null || _a === void 0 ? void 0 : _a.length.should.be.gte(0);
        model.should.not.be.null;
        yield modelManagement.DeleteModel(`${model.id}`);
    }));
    it("should GET specific version of a model ", () => __awaiter(void 0, void 0, void 0, function* () {
        modelManagement.should.not.be.undefined;
        const oVersion = yield modelManagement.GetModelLastVersion(`${mmModelId}`);
        oVersion.should.not.be.undefined;
        oVersion.should.not.be.null;
        const sVersion = yield modelManagement.GetModelVersion(`${mmModelId}`, `${oVersion.id}`);
        sVersion.should.not.be.undefined;
        sVersion.should.not.be.null;
        sVersion.number.should.be.equals(oVersion.number);
    }));
    it("should POST new version of a model", () => __awaiter(void 0, void 0, void 0, function* () {
        modelManagement.should.not.be.undefined;
        testModelVersionDefinition.expirationDate = futureTimeOffset.toISOString();
        const lastVersion = yield modelManagement.PostModelVersion(`${mmModelId}`, testModelVersionDefinition, {
            buffer: Buffer.from("xyz"),
            fileName: `xyz${timeOffset}_mm_version_B.txt`,
            mimeType: "text/plain",
        });
        lastVersion.should.not.be.undefined;
        lastVersion.should.not.be.null;
        lastVersion.id.should.not.be.undefined;
        lastVersion.id.should.not.be.null;
        lastVersion.number.should.not.be.undefined;
        lastVersion.number.should.not.be.null;
        yield modelManagement.DeleteModelVersion(`${mmModelId}`, `${lastVersion.id}`);
    }));
    it("should DELETE last version of a model", () => __awaiter(void 0, void 0, void 0, function* () {
        modelManagement.should.not.be.undefined;
        testModelDefinition.name = `xyz_${timeOffset}_mm_version_C`;
        const model = yield modelManagement.PostModel(testModelDefinition, {
            buffer: Buffer.from("xyz"),
            fileName: `xyz${timeOffset}_mm_version_C.txt`,
            mimeType: "text/plain",
        });
        model.should.not.be.undefined;
        model.should.not.be.null;
        testModelVersionDefinition.expirationDate = futureTimeOffset.toISOString();
        const lastVersion = yield modelManagement.PostModelVersion(`${model.id}`, testModelVersionDefinition, {
            buffer: Buffer.from("xyz"),
            fileName: `xyz${timeOffset}_mm_version_D.txt`,
            mimeType: "text/plain",
        });
        lastVersion.should.not.be.undefined;
        lastVersion.should.not.be.null;
        const modelVersions = yield modelManagement.GetModelVersions({
            modelId: `${model.id}`,
            pageNumber: 0,
            pageSize: 100,
        });
        modelVersions.should.not.be.undefined;
        modelVersions.should.not.be.null;
        yield modelManagement.DeleteModelLastVersion(`${model.id}`);
        const newmodelVersions = yield modelManagement.GetModelVersions({
            modelId: `${model.id}`,
            pageNumber: 0,
            pageSize: 100,
        });
        newmodelVersions.should.not.be.undefined;
        newmodelVersions.should.not.be.null;
        newmodelVersions.versions.length.should.be.equals(modelVersions.versions.length - 1);
        yield modelManagement.DeleteModel(`${model.id}`);
    }));
    it("should DELETE a specific version of a model", () => __awaiter(void 0, void 0, void 0, function* () {
        modelManagement.should.not.be.undefined;
        testModelDefinition.name = `xyz_${timeOffset}_mm_version_E`;
        const model = yield modelManagement.PostModel(testModelDefinition, {
            buffer: Buffer.from("xyz"),
            fileName: `xyz${timeOffset}_mm_version_E.txt`,
            mimeType: "text/plain",
        });
        model.should.not.be.undefined;
        model.should.not.be.null;
        const oVersion = yield modelManagement.GetModelLastVersion(`${model.id}`);
        oVersion.should.not.be.undefined;
        oVersion.should.not.be.null;
        testModelVersionDefinition.expirationDate = futureTimeOffset.toISOString();
        const lastVersion = yield modelManagement.PostModelVersion(`${model.id}`, testModelVersionDefinition, {
            buffer: Buffer.from("xyz"),
            fileName: `xyz${timeOffset}_mm_version_F.txt`,
            mimeType: "text/plain",
        });
        lastVersion.should.not.be.undefined;
        lastVersion.should.not.be.null;
        yield modelManagement.DeleteModelVersion(`${model.id}`, `${oVersion.id}`);
        const nVersion = yield modelManagement.GetModelLastVersion(`${model.id}`);
        nVersion.should.not.be.undefined;
        nVersion.should.not.be.null;
        nVersion.number.should.be.equals(`${2.0}`);
        yield modelManagement.DeleteModel(`${model.id}`);
    }));
    it("should PATCH specific version of a model without changing the model", () => __awaiter(void 0, void 0, void 0, function* () {
        modelManagement.should.not.be.undefined;
        testModelDefinition.name = `xyz_${timeOffset}_mm_version_G`;
        const oModel = yield modelManagement.PostModel(testModelDefinition, {
            buffer: Buffer.from("xyz"),
            fileName: `xyz${timeOffset}_mm_version_G.txt`,
            mimeType: "text/plain",
        });
        oModel.should.not.be.undefined;
        oModel.should.not.be.null;
        const oVersion = yield modelManagement.GetModelLastVersion(`${oModel.id}`);
        oVersion.should.not.be.undefined;
        oVersion.should.not.be.null;
        testModelVersionDefinition.expirationDate = futureTimeOffset.toISOString();
        const lastVersion = yield modelManagement.PatchLastModelVersion(`${oModel.id}`, testModelVersionDefinition);
        lastVersion.should.not.be.undefined;
        lastVersion.should.not.be.null;
        const nVersion = yield modelManagement.GetModelLastVersion(`${oModel.id}`);
        nVersion.should.not.be.undefined;
        nVersion.should.not.be.null;
        nVersion.number.should.be.equals(`${2.0}`);
        nVersion.number.should.not.be.equals(oVersion.number);
        const nModel = yield modelManagement.GetModel(`${oModel.id}`);
        nModel.should.not.be.undefined;
        nModel.should.not.be.null;
        nModel.id.should.be.equals(oModel.id);
        nModel.name.should.be.equals(oModel.name);
        nModel.description.should.be.equals(oModel.description);
        yield modelManagement.DeleteModel(`${oModel.id}`);
    }));
});
function deleteModels(mm) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.sleep)(2000);
        const models = (yield mm.GetModels({
            filter: JSON.stringify({
                name: "xyz*",
            }),
            sort: "desc",
            pageNumber: 0,
            pageSize: 1,
        }));
        yield (0, test_utils_1.sleep)(2000);
        for (const x of models.models) {
            yield mm.DeleteModel(x.id);
        }
    });
}
//# sourceMappingURL=model-management-model-version.spec.js.map