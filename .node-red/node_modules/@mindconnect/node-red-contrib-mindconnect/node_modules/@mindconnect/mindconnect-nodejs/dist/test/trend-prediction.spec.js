"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
require("url-search-params-polyfill");
const sdk_1 = require("../src/api/sdk");
const utils_1 = require("../src/api/utils");
const command_utils_1 = require("../src/cli/commands/command-utils");
const test_utils_1 = require("./test-utils");
chai.should();
describe("[SDK] TrendPredictionClient", () => {
    const auth = (0, utils_1.loadAuth)();
    const sdk = new sdk_1.MindSphereSdk(Object.assign(Object.assign({}, auth), { basicAuth: (0, utils_1.decrypt)(auth, (0, test_utils_1.getPasskeyForUnitTest)()) }));
    const trendPredictionClient = sdk.GetTrendPredictionClient();
    const data = (0, command_utils_1.generateTestData)(50, (x) => {
        return x * 1.0;
    }, "Temperature");
    // the tests use  the simple polynomial function f(x) = x^2 -15x + 7
    // the trendprediction should be able to use the polynomial regression to find the polynomial which
    // was used to generate the data
    //
    // * https://www.wolframalpha.com/input/?i=x%5E2-15x%2B7
    //
    // for the simplicity we are only using single independent variable in the unit tests
    // * https://developer.mindsphere.io/apis/analytics-trendprediction/api-trendprediction-basics.html#polynomial-regression
    const powerOutputSensor = (0, command_utils_1.generateTestData)(50, (x) => {
        return Math.pow(x, 2) - 15 * x + 7; // f(x) = x^2 -15x + 7; https://www.wolframalpha.com/input/?i=x%5E2-15x%2B7
    }, "powerOutputSensor");
    const trainingData = {
        modelConfiguration: {
            polynomialDegree: 2,
        },
        metadataConfiguration: {
            outputVariable: {
                entityId: "UnitTestTurbine1",
                propertySetName: "monitoringModule",
                propertyName: "powerOutputSensor",
            },
            inputVariables: [
                {
                    entityId: "UnitTestTurbine1",
                    propertySetName: "combustionSubpart1",
                    propertyName: "Temperature",
                },
            ],
        },
        trainingData: [
            {
                variable: {
                    entityId: "UnitTestTurbine1",
                    propertySetName: "monitoringModule",
                },
                timeSeries: powerOutputSensor,
            },
            {
                variable: {
                    entityId: "UnitTestTurbine1",
                    propertySetName: "combustionSubpart1",
                },
                timeSeries: data,
            },
        ],
    };
    it("SDK should not be undefined", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
        trendPredictionClient.should.not.be.undefined;
    }));
    it("SDK should train the model and predict the results in two separate steps", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
        trendPredictionClient.should.not.be.undefined;
        const trainedModel = yield trendPredictionClient.Train(trainingData);
        trainedModel.id.should.not.be.undefined;
        // console.log(JSON.stringify(trainedModel, null, 2));
        const prediction = {
            modelConfiguration: { modelId: trainedModel.id },
            predictionData: [
                {
                    variable: {
                        entityId: "UnitTestTurbine1",
                        propertySetName: "combustionSubpart1",
                    },
                    timeSeries: [
                        {
                            _time: new Date().toISOString(),
                            Temperature: "4.0",
                        },
                        {
                            _time: new Date().toISOString(),
                            Temperature: "14.0",
                        },
                        {
                            _time: new Date().toISOString(),
                            Temperature: "-4.0",
                        },
                    ],
                },
            ],
        };
        const predictionResult = yield trendPredictionClient.Predict(prediction);
        if (new Date() < new Date(2021, 5, 15)) {
            console.log("Skipping test until MindSphere fixes this.");
            return;
        }
        Math.round(predictionResult[0].timeSeries[0]["powerOutputSensor"]).should.be.equal(-37); // f(x)=x*x -15x + 7 ;// https://www.wolframalpha.com/input/?i=x%5E2-15x%2B7%3B+x+%3D+4
        Math.round(predictionResult[0].timeSeries[1]["powerOutputSensor"]).should.be.equal(-7); // f(x)=x*x -15x + 7 ;// https://www.wolframalpha.com/input/?i=x%5E2-15x%2B7%3B+x+%3D+14
        Math.round(predictionResult[0].timeSeries[2]["powerOutputSensor"]).should.be.equal(83); // f(x)=x*x -15x + 7 ;// https://www.wolframalpha.com/input/?i=x%5E2-15x%2B7%3B+x+%3D+-4
    }));
    it("SDK should train and predict in one step as well", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
        trendPredictionClient.should.not.be.undefined;
        const prediction = {
            predictionData: [
                {
                    variable: {
                        entityId: "UnitTestTurbine1",
                        propertySetName: "combustionSubpart1",
                    },
                    timeSeries: [
                        {
                            _time: new Date().toISOString(),
                            Temperature: "4.0",
                        },
                        {
                            _time: new Date().toISOString(),
                            Temperature: "14.0",
                        },
                        {
                            _time: new Date().toISOString(),
                            Temperature: "-4.0",
                        },
                    ],
                },
            ],
        };
        const predictionResult = yield trendPredictionClient.TrainAndPredict(Object.assign(Object.assign({}, trainingData), prediction));
        if (new Date() < new Date(2021, 5, 15)) {
            console.log("Skipping test until MindSphere fixes this.");
            return;
        }
        Math.round(predictionResult[0].timeSeries[0]["powerOutputSensor"]).should.be.equal(-37); // f(x)=x*x -15x + 7 ;// https://www.wolframalpha.com/input/?i=x%5E2-15x%2B7%3B+x+%3D+4
        Math.round(predictionResult[0].timeSeries[1]["powerOutputSensor"]).should.be.equal(-7); // f(x)=x*x -15x + 7 ;// https://www.wolframalpha.com/input/?i=x%5E2-15x%2B7%3B+x+%3D+14
        Math.round(predictionResult[0].timeSeries[2]["powerOutputSensor"]).should.be.equal(83); // f(x)=x*x -15x + 7 ;// https://www.wolframalpha.com/input/?i=x%5E2-15x%2B7%3B+x+%3D+-4
    }));
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const models = yield trendPredictionClient.GetModels({
                entityId: "UnitTestTurbine1",
            });
            // console.log(`Deleting ${models.length} model(s)`);
            models.should.not.be.undefined;
            for (const model of models) {
                yield trendPredictionClient.DeleteModel(model.id); // the id of the model is not optional!
            }
        }
        catch (_a) { }
    }));
});
//# sourceMappingURL=trend-prediction.spec.js.map