"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MindConnectBase = exports.isTokenRotation = void 0;
const cross_fetch_1 = require("cross-fetch");
const debug = require("debug");
const utils_1 = require("./utils");
const version_1 = require("../version");
const HttpsProxyAgent = require("https-proxy-agent");
const log = debug("mindconnect");
function isTokenRotation(obj) {
    const tr = obj;
    return (tr.GetGateway !== undefined &&
        tr.GetTenant !== undefined &&
        tr.GetToken !== undefined &&
        tr.RenewToken !== undefined &&
        tr instanceof Object &&
        typeof tr.GetGateway === "function" &&
        typeof tr.GetTenant === "function" &&
        typeof tr.GetToken === "function" &&
        typeof tr.RenewToken === "function");
}
exports.isTokenRotation = isTokenRotation;
/**
 * Base class for mindconnect agent (and setup) which provides headers and proxy handling.
 *
 * @export
 * @abstract
 * @class MindConnectBase
 */
class MindConnectBase {
    constructor() {
        this._headers = {
            Accept: "*/*",
            "X-Powered-By": "meowz",
            "User-Agent": `${version_1.MC_NAME} (${version_1.MC_VERSION})`,
        };
        /**
         * Http headers used for /exchange endpoint handling.
         *
         * @protected
         * @memberof MindConnectBase
         */
        this._multipartHeaders = Object.assign(Object.assign({}, this._headers), { "Content-Type": "multipart/mixed; boundary=mindspheremessage" });
        this._multipartFormData = Object.assign(Object.assign({}, this._headers), { "Content-Type": "multipart/form-data; boundary=--mindsphere" });
        /**
         * Http headers used for onboarding message.
         *
         * @protected
         * @memberof MindConnectBase
         */
        this._apiHeaders = Object.assign(Object.assign({}, this._headers), { "Content-Type": "application/json" });
        this._octetStreamHeaders = Object.assign(Object.assign({}, this._headers), { "Content-Type": "application/octet-stream" });
        /**
         * Http headers used to register the client assertion and acquire the /exchange token.
         *
         * @protected
         * @memberof MindConnectBase
         */
        this._urlEncodedHeaders = Object.assign(Object.assign({}, this._headers), { "Content-Type": "application/x-www-form-urlencoded" });
        const proxy = process.env.http_proxy || process.env.HTTP_PROXY;
        log(`Proxy: ${proxy}`);
        this._proxyHttpAgent = proxy ? new HttpsProxyAgent(proxy) : null;
    }
    /**
     * perform http action
     *
     * @param {({
     *         verb: "GET" | "POST" | "PATCH" | "PUT" | "DELETE";
     *         gateway: string;
     *         baseUrl: string;
     *         authorization: string;
     *         body?: Object;
     *         message?: string;
     *         octetStream?: boolean;
     *         multiPartFormData?: boolean;
     *         additionalHeaders?: Object;
     *         noResponse?: boolean;
     *         rawResponse?: boolean;
     *         returnHeaders?: boolean;
     *         ignoreCodes?: number[];
     *     })} {
     *         verb,
     *         gateway,
     *         baseUrl,
     *         authorization,
     *         body,
     *         message,
     *         octetStream,
     *         multiPartFormData,
     *         additionalHeaders,
     *         noResponse,
     *         rawResponse,
     *         returnHeaders,
     *         ignoreCodes,
     *     }
     * @returns {Promise<Object>}
     *
     * @memberOf MindConnectBase
     */
    HttpAction({ verb, gateway, baseUrl, authorization, body, message, octetStream, multiPartFormData, additionalHeaders, noResponse, rawResponse, returnHeaders, ignoreCodes, }) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders = additionalHeaders || {};
            let apiheaders = octetStream ? this._octetStreamHeaders : this._apiHeaders;
            apiheaders = multiPartFormData ? this._multipartFormData : apiheaders;
            ignoreCodes = ignoreCodes || [];
            let headers = Object.assign(Object.assign({}, apiheaders), { Authorization: `Bearer ${authorization}` });
            if (verb === "GET" || verb === "DELETE") {
                delete headers["Content-Type"];
            }
            headers = (0, utils_1.removeUndefined)(Object.assign(Object.assign({}, headers), additionalHeaders));
            const url = `${gateway}${baseUrl}`;
            log(`${message} Headers ${JSON.stringify(headers)} Url ${url}`);
            try {
                const request = { method: verb, headers: headers, agent: this._proxyHttpAgent };
                if (verb !== "GET" && verb !== "DELETE") {
                    request.body = octetStream || multiPartFormData ? body : JSON.stringify(body);
                }
                const response = yield (0, cross_fetch_1.default)(url, request);
                const codeIgnored = ignoreCodes.indexOf(response.status) >= 0;
                !codeIgnored && !response.ok && (0, utils_1.throwError)(`${response.statusText} ${yield response.text()}`);
                !codeIgnored &&
                    (response.status < 200 || response.status > 299) &&
                    (0, utils_1.throwError)(`invalid response ${JSON.stringify(response)}`);
                if (codeIgnored)
                    return undefined;
                if (rawResponse)
                    return response;
                if (noResponse) {
                    if (returnHeaders) {
                        return response.headers;
                    }
                    return {};
                }
                const json = yield response.json();
                log(`${message} Response ${JSON.stringify(json)}`);
                return json;
            }
            catch (err) {
                log(err);
                throw new Error(`Network error occured ${err.message}`);
            }
        });
    }
}
exports.MindConnectBase = MindConnectBase;
//# sourceMappingURL=mindconnect-base.js.map