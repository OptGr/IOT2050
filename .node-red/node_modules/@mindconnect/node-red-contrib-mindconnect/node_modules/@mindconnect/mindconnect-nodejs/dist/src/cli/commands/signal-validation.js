"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const fs = require("fs");
const utils_1 = require("../../api/utils");
const command_utils_1 = require("./command-utils");
let color = (0, command_utils_1.getColor)("blue");
exports.default = (program) => {
    program
        .command("signal-validation")
        .alias("sv")
        .option("-f, --file <timeseries>", `timeseries file`, `timeseries-sample.json`)
        .option("-o, --output <output>", `result-file (signal-validation-${color("mode")}.json)`)
        .option("-m, --mode [testdata|range|spike|jumps|noise|gaps|interpolate|bias]", `mode see ${color("@ Additional Documentation")}`)
        .option("-n, --variablename [variablename]", `this variable will be taken from timeseries`, `variable1`)
        .option("-l, --lowerlimit [lowerlimit]", `processing lower limit (for range)`)
        .option("-u, --upperlimit [upperlimit]", `processing upper limit (for range)`)
        .option("-w, --windowsize [windowsize]", `processing window size`)
        .option("-r, --windowradius [windowradius]", `processing window radius (for noise)`)
        .option("-t, --threshold [threshold]", `processing threshold`)
        .option("-s, --step [step]", `processing step (for bias detection) `)
        .option("-z, --size [size]", `generating test data size `, "100")
        .option("-y, --retry <number>", "retry attempts before giving up", "3")
        .option("-p, --passkey <passkey>", `passkey`)
        .option("-v, --verbose", "verbose output")
        .description(`${color("perform signal validation @")}`)
        .action((options) => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                checkRequiredParameters(options);
                const sdk = (0, command_utils_1.getSdk)(options);
                color = (0, command_utils_1.adjustColor)(color, options, true);
                (0, command_utils_1.homeDirLog)(options.verbose, color);
                (0, command_utils_1.proxyLog)(options.verbose, color);
                const signalvalidation = sdk.GetSignalValidationClient();
                if (options.mode === "testdata") {
                    createFile(options);
                    process.exit(0);
                }
                const timeseriesData = fs.readFileSync(options.file).toString();
                const timeseries = JSON.parse(timeseriesData);
                let result;
                if (options.mode === "range") {
                    result = yield (0, utils_1.retry)(options.retry, () => signalvalidation.DetectRangeViolations(timeseries, {
                        variableName: options.variablename,
                        lowerLimit: options.lowerlimit,
                        upperLimit: options.upperlimit,
                    }));
                }
                else if (options.mode === "spike") {
                    result = yield (0, utils_1.retry)(options.retry, () => signalvalidation.DetectSpikes(timeseries, {
                        variableName: options.variablename,
                        windowSize: options.windowsize,
                    }));
                }
                else if (options.mode === "jumps") {
                    result = yield (0, utils_1.retry)(options.retry, () => signalvalidation.DetectJumps(timeseries, {
                        variableName: options.variablename,
                        windowSize: options.windowsize,
                    }));
                }
                else if (options.mode === "noise") {
                    result = yield (0, utils_1.retry)(options.retry, () => signalvalidation.DetectNoise(timeseries, {
                        variableName: options.variablename,
                        windowRadius: options.windowradius,
                        threshold: options.threshold,
                    }));
                }
                else if (options.mode === "gaps") {
                    result = yield (0, utils_1.retry)(options.retry, () => signalvalidation.DetectGaps(timeseries, {
                        variableName: options.variablename,
                        threshold: options.threshold,
                    }));
                }
                else if (options.mode === "interpolate") {
                    result = yield (0, utils_1.retry)(options.retry, () => signalvalidation.DetectGapsAndInterpolate(timeseries, {
                        variableName: options.variablename,
                        threshold: options.threshold,
                    }));
                }
                else if (options.mode === "bias") {
                    result = yield (0, utils_1.retry)(options.retry, () => signalvalidation.DetectBias(timeseries, {
                        variableName: options.variablename,
                        windowSize: options.windowsize,
                        threshold: options.threshold,
                        step: options.step,
                    }));
                }
                else {
                    throw new Error(`inalid  mode ${options.mode}`);
                }
                const validationResult = JSON.stringify(result, null, 2);
                (0, command_utils_1.verboseLog)(validationResult, options.verbose);
                const outputFile = options.output || `signal-validation-${options.mode}.json`;
                fs.writeFileSync(outputFile, validationResult);
                console.log(`The result of the ${color(options.mode)} operation was written into ${color(outputFile)} file.`);
            }
            catch (err) {
                (0, command_utils_1.errorLog)(err, options.verbose);
            }
        }))();
    })
        .on("--help", () => {
        (0, console_1.log)("\n  Examples:\n");
        (0, console_1.log)(`    mc signal-validation --mode range --lowerlimit \ -1 --upperlimit 1  \t performes the range validation for range [-1..1]`);
        (0, console_1.log)(`    mc signal-validation -mode jumps --windowsize 12  \t\t\t searches for jumps in the data`);
        (0, console_1.log)(`    mc signal-validation --mode interpolate --threshold 1000  \t\t interpolates a value for every gap > 1000ms`);
        (0, console_1.log)("\n  Additional Documentation:\n");
        (0, console_1.log)(`    ${color("https://developer.mindsphere.io/apis/analytics-signalvalidation/api-signalvalidation-basics.html")}`);
        (0, command_utils_1.serviceCredentialLog)(color);
    });
};
function createFile(options) {
    fs.existsSync(options.file) && (0, utils_1.throwError)(`The file ${options.file} already exists.`);
    const data = (0, command_utils_1.generateTestData)(options.size, (x) => {
        let result = Math.sin(x);
        if (x === 40 || x === 41)
            result = Math.sin(x) + 18; // create spike
        if (x >= 20 && x <= 30)
            result = Math.sin(x) * Math.random() * 5 + Math.random(); // create noise
        if (x === 95 || x === 96)
            result = undefined;
        return result;
    });
    fs.writeFileSync(options.file, JSON.stringify(data, undefined, 2));
}
function checkRequiredParameters(options) {
    !options.mode &&
        (0, command_utils_1.errorLog)("You have to provide the mode for the command. Run mc sv --help for full syntax and examples.", true);
    options.mode !== "testdata" &&
        !options.variablename &&
        (0, command_utils_1.errorLog)("You have to provide the variable name for signal validation operation", true);
    options.mode === "testdata" &&
        !options.size &&
        !parseInt(options.size) &&
        (0, command_utils_1.errorLog)("Size must be a number > 0", true);
    options.mode === "range" &&
        (!options.lowerlimit || !options.upperlimit) &&
        (0, command_utils_1.errorLog)("Required parameters for range: variablename, lowerLimit, upperLimit", true);
    options.mode === "spike" &&
        !options.windowsize &&
        (0, command_utils_1.errorLog)("Required parameters for spike: variablename, windowsize", true);
    options.mode === "jumps" &&
        !options.windowsize &&
        (0, command_utils_1.errorLog)("Required parameters for jumps: variableName, windowsize", true);
    options.mode === "noise" &&
        (!options.windowradius || !options.threshold) &&
        (0, command_utils_1.errorLog)("Required parameters for noise: variablename, windowradius, threshold", true);
    options.mode === "gaps" &&
        !options.threshold &&
        (0, command_utils_1.errorLog)("Required parameters for gaps: variableName, threshold", true);
    options.mode === "interpolate" &&
        !options.threshold &&
        (0, command_utils_1.errorLog)("Required parameters for interpolate: variablename, threshold", true);
    options.mode === "bias" &&
        (!options.threshold || !options.step || !options.windowsize) &&
        (0, command_utils_1.errorLog)("Required parameters for interpolate: variablename, threshold, step, windowsize", true);
}
//# sourceMappingURL=signal-validation.js.map