import { SdkClient } from "../common/sdk-client";
import { DeploymentWorkflowModels, DeviceConfigurationModels, DeviceManagementModels, DeviceStatusModels, EdgeAppDeploymentModels, EdgeAppInstanceModels, FirmwareDeploymentModels } from "./open-edge-models";
/**
 * Device Management API
 * Device Managment API can be used by device builders to define device types and by device operators to manage device instances. At the moment, device types are only visible to the tenant creating them.  Devices are the basis for managing software and configuration in other edge APIs.     Each device is associated to a device type, which defines the firmware to be installed on the device. Once a device is created, the device type association cannot be changed anymore. Agents must be associated to devices to be able to access the Deployment Workflow API.
 *
 * @export
 * @class DeviceManagementClient
 * @extends {SdkClient}
 */
export declare class DeviceManagementClient extends SdkClient {
    private _baseUrl;
    /**
     * * DeviceTypes
     *
     * Get all device types
     * @summary Get all device types
     * @param {{
     *         owner?: string;
     *         code?: string;
     *         assetTypeId?: string;
     *         page?: number;
     *         size?: number;
     *         sort?: string;
     *     }} [params]
     * @param {string} [params.owner] Owner tenant
     * @param {string} [params.code] Device Type Code
     * @param {string} [params.assetTypeId] Associated asset type id
     * @param {number} [params.size] The maximum number of elements returned in one page
     * @param {number} [params.page] The (0-based) index of the page
     * @param {string} [params.sort] The order of returned elements.&lt;br/&gt;Multiple fields could be used separated by commas (e.g. &#39;field1,field2&#39;).&lt;br/&gt;Descending order could be requested by appending &#39;,desc&#39; at the end of parameter.(e.g. &#39;field1,field2,desc&#39;)
     * @example await deviceManagement.GetDeviceTypes();
     * @example await deviceManagement.GetDeviceTypes({sort: 'id,name'});

     * @returns {Promise<DeviceManagementModels.PaginatedDeviceType>}
     *
     * @memberOf DeviceManagementClient
     */
    GetDeviceTypes(params?: {
        owner?: string;
        code?: string;
        assetTypeId?: string;
        page?: number;
        size?: number;
        sort?: string;
    }): Promise<DeviceManagementModels.PaginatedDeviceType>;
    /**
     * * DeviceTypes
     *
     * Get device type by given device type id
     * @summary Get device type by given device type id
     * @param {string} id Id of device type
     * @returns {Promise<DeviceManagementModels.DeviceType>}
     *
     * @example await deviceManagement.GetDeviceType("mdsp.EnvironmentDevice")
     * @memberOf DeviceManagementClient
     */
    GetDeviceType(id: string): Promise<DeviceManagementModels.DeviceType>;
    /**
     * * DeviceTypes
     * Create a new device type
     * @summary Create a new device type
     * @param {DeviceType} deviceType Device type fields
     * @returns {Promise<DeviceManagementModels.DeviceType>}
     *
     * @example await deviceManagement.PostDeviceType (myDeviceType)
     * @memberOf DeviceManagementClient
     */
    PostDeviceType(deviceType: DeviceManagementModels.DeviceType): Promise<DeviceManagementModels.DeviceType>;
    /**
     * * DeviceTypes
     * Update device type by given device type id
     * @summary Update device type by given device type id
     * @param {string} id Id of device type
     * @param {DeviceManagementModels.DeviceTypeUpdate} deviceType Device type info in JSON format
     * @returns {Promise<DeviceManagementModels.DeviceType>}
     *
     * @example await deviceManagement.PostDeviceType (myDeviceType)
     * @memberOf DeviceManagementClient
     */
    PatchDeviceType(id: string, deviceType: DeviceManagementModels.DeviceTypeUpdate): Promise<DeviceManagementModels.DeviceType>;
    /**
     * Deletes the device type with the specified id # Idempotency # This endpoint provides idempotent deletes, i.e., repeated deletes to the same resource will always return 204 responses regardless whether the resource existed in the first place or not.
     * @summary Delete devicetype
     * @param {string} id id of the device tye
     *
     * @example await deviceManagement.DeleteDeviceType("mdsp.EnvironmentDevice")
     *
     * @memberOf DeviceManagementClient
     */
    DeleteDeviceType(id: string): Promise<void>;
    /**
     * * Devices
     * Returns a paginated list of all devices within the caller tenant  Searching / filtering is currently not supported
     * @summary List devices
     * @summary List devices
     * @param {{
     *         assetId?: string;
     *         page?: number;
     *         size?: number;
     *     }} [params]
     * @param {number} [params.size] The maximum number of elements returned in one page
     * @param {number} [params.page] The (0-based) index of the page
     * @param {string} [params.assetId] Associated asset id
     *
     * @example await deviceManagement.GetDevices();
     * @example await deviceManagement.GetDevices({size: 10});

     * @returns {Promise<DeviceManagementModels.PaginatedDevice>}
     *
     * @memberOf DeviceManagementClient
     */
    GetDevices(params?: {
        assetId?: string;
        page?: number;
        size?: number;
    }): Promise<DeviceManagementModels.PaginatedDevice>;
    /**
     * * Devices
     * Returns the specified device
     * @summary Fetch a device
     * @param {string} id id of the device
     * @returns {Promise<DeviceManagementModels.Device>}
     *
     * @example await deviceManagement.GetDevice("mdsp.EnvironmentDevice")
     * @memberOf DeviceManagementClient
     */
    GetDevice(id: string): Promise<DeviceManagementModels.Device>;
    /**
     * * Devices
     * Updates the device.  # Constraints # * All fields are optional. If a field is null or is omitted, the current value will be preserved. * If the read-only fields `id` and `deviceTypeId` are present, they must match the current value or an error is returned. * The `agents` list and `properties` json block are replaced with the content specified in the request if present. Partial modification of these elements is not possible.
     * @summary Update device
     * @param {string} id id of the device
     * @param {DeviceManagementModels.DeviceUpdate} deviceMetadata Device metadata
     * @returns {Promise<Device>}
     *
     * @example await deviceManagement.PatchDevice("mdsp.EnvironmentDevice", myDevice;Metadata)
     * @memberOf DeviceManagementClient
     */
    PatchDevice(id: string, deviceMetadata: DeviceManagementModels.DeviceUpdate): Promise<DeviceManagementModels.Device>;
    /**
     * * Devices
     * Creates a new device.   # Constraints #  The (mandatory) device type cannot be modified after the device has been created.
     * @summary Create a new device
     * @param {DeviceManagementModels.DeviceCreation} deviceMetadata Device metadata
     * @returns {Promise<DeviceManagementModels.Device}
     *
     * @example await deviceManagement.PostDeviceType (myDeviceType)
     * @memberOf DeviceManagementClient
     */
    PostDevice(deviceMetadata: DeviceManagementModels.DeviceCreation): Promise<DeviceManagementModels.Device>;
    /**
     * Deletes the device with the specified id # Idempotency # This endpoint provides idempotent deletes, i.e., repeated deletes to the same resource will always return 204 responses regardless whether the resource existed in the first place or not.
     * @summary Delete device
     * @param {string} id id of the device
     *
     * @example await deviceManagement.DeleteDevice("mdsp.EnvironmentDevice")
     *
     * @memberOf DeviceManagementClient
     */
    DeleteDevice(id: string): Promise<void>;
}
/**
 * Device Status API
 * Device Status API allows devices to provide status information to be queried by backend applications. Device status comprises information about device health, connection status, and the installed software inventory. Health information can be flexibly extended to contain custom health information.
 *
 *
 * @export
 * @class DeviceStatusManagementClient
 * @extends {SdkClient}
 */
export declare class DeviceStatusManagementClient extends SdkClient {
    private _baseUrl;
    /**
     * Allows the devices to report on the device health status
     * @summary Report device health status
     * @param {string} id ID of the device
     * @param {DeviceStatusModels.DeviceHealthStatusReportInput} healthStatusReport Report of the device health status
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    PatchDeviceHealth(id: string, healthStatusReport: DeviceStatusModels.DeviceHealthStatusReportInput): Promise<DeviceStatusModels.DeviceHealthStatusReport>;
    /**
     * Retrieves the device health status
     * @summary Retrieves the device health status
     * @param {string} id id of the device
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    GetDeviceHealth(id: string): Promise<DeviceStatusModels.DeviceHealthStatusReport>;
    /**
     * Persist data configuration health status.
     * @summary Persist data configuration health status
     * @param {string} id ID of the device
     * @param {DeviceStatusModels.DataConfigHealthInput} dataConfig Data configuration health status
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    PatchDeviceHealthDataConfig(id: string, dataConfig: DeviceStatusModels.DataConfigHealthInput): Promise<DeviceStatusModels.DataConfigHealth>;
    /**
     * Retrieves the data configuration health status.
     * @summary Retrieves the data configuration health status
     * @param {string} id id of the device
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    GetDeviceHealthDataConfig(id: string): Promise<DeviceStatusModels.DeviceHealthStatusReport>;
    /**
     * Sends the heartbeat.
     * @summary Sends the heartbeat
     * @param {string} id ID of the device
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    PostDeviceHeartbeat(id: string): Promise<Response>;
    /**
     * Retrieves the device connection status
     * @summary Retrieves the device connection status
     * @param {string} id ID of the device
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    GetDeviceConnectionStatus(id: string): Promise<DeviceStatusModels.OnlineStatus>;
    /**
     * Returns a paginated list of all software (firmware, apps, etc) installed on the device  # Searching / Filtering # The following filter criteria can be specified as query parameters * *type*: return only firmware or apps or ... * *softwareId*: return only software belonging to the specified product (potentially multiple different versions could be installed at the same time)
     * @summary List software installed on device
     * @param {string} id ID of the device
     * @param {'FIRMWARE' | 'APP'} [type] type of software
     * @param {string} [softwareId] id of the software
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    GetDeviceSoftwares(id: string, type?: "FIRMWARE" | "APP", softwareId?: string, page?: number, size?: number): Promise<DeviceStatusModels.PaginatedSoftwareInventoryRecord>;
    /**
     * Returns the software inventory of the device.
     * @summary Get inventory
     * @param {string} id ID of the device
     * @param {'FIRMWARE' | 'APP'} [type] type of software
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    GetDeviceInventory(id: string, type?: "FIRMWARE" | "APP"): Promise<DeviceStatusModels.InventoryArray>;
    /**
     * Updates the software inventory of the device. The whole inventory is replaced with the content sent by the device.
     * @summary Update inventory
     * @param {string} id ID of the device
     * @param {Array<DeviceStatusModels.InventoryEntry>} installationSoftwareInventory List of installed software
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    PatchDeviceSoftwareInventory(id: string, installationSoftwareInventory: Array<DeviceStatusModels.InventoryEntry>): Promise<Array<DeviceStatusModels.InventoryEntry>>;
    /**
     * Updates the software inventory of the device for firmware type Provided as a convenience method for device implementations that use separate processes for managing firmware and app updates. By utilizing this endpoint the device does not have to aggregate firmware and apps into a wholistic list but can update firmware independently.
     * @summary Update firmware inventory on a device
     * @param {string} id ID of the device
     * @param {Array<DeviceStatusModels.InventoryFirmwareEntry>} installationFirmwareInventory List of installed firmware
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    PatchDeviceFirmwareInventory(id: string, installationFirmwareInventory: Array<DeviceStatusModels.InventoryFirmwareEntry>): Promise<Array<DeviceStatusModels.InventoryEntry>>;
    /**
     * Updates the software inventory of the device for edge application type Provided as a convenience method for device implementations that use separate processes for managing firmware and app updates. By utilizing this endpoint the device does not have to aggregate firmware and apps into a wholistic list but can update edge applications independently.
     * @summary Update edge application inventory on a device
     * @param {string} id ID of the device
     * @param {Array<DeviceStatusModels.InventoryApplicationEntry>} installationApplicationInventory List of installed edge applications
     * @throws {DeviceStatusModels.RequiredError}
     * @memberof DeviceStatusManagementClient
     */
    PatchDeviceApplicationInventory(id: string, installationApplicationInventory: Array<DeviceStatusModels.InventoryApplicationEntry>): Promise<DeviceStatusModels.InventoryApplicationArray>;
}
/**
 * Device Configuration API
 * Device Configuration API can be used to manage device configuration files and to coordinate configuration tasks for devices. The provided operations do not trigger any actions themselves, but are meant to be used by northbound applications to coordinate user and device efforts. Configuration tasks consist of different states that require the app operator user and the target device to participate in order to complete a task.  Devices should use Deployment Workflow API to find out about configuration tasks. Device Configuration Service is based on Deployment Workflow Service and reflects all changes applied through Deployment Workflow API. Once a task is created in this API, it will be available also through Deployment Workflow API. The configuration task status can be advanced at this API or at Deployment Workflow API.
 *
 * @export
 * @class DeviceConfigurationClient
 * @extends {SdkClient}
 */
export declare class DeviceConfigurationClient extends SdkClient {
    private _baseUrl;
    /**
     * Returns a paginated list of all tasks of the specified device ordered by descending creation date (newest tasks first)
     * @summary List all tasks of a device
     * @param {string} id Id of the device that owns the task.
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @param {string} [sort] The order in which the elements are returned. Multiple fields could be used spearated by comma
     * @returns {Promise<DeviceConfigurationModels.PaginatedConfigurationTask>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetConfigurationTasks("mdsp.myDevice")
     * @memberof DeviceConfigurationClient
     */
    GetConfigurationTasks(id: string, size?: number, page?: number, sort?: string): Promise<DeviceConfigurationModels.PaginatedConfigurationTask>;
    /**
     * Returns the specified task   # Current State #   The `currentState` field contains information about the current state in the state machine as well as the progress inside this state (if updated by the device)   # History #  The 'history' field contains a \"trace\" of all the past states this task was in, as well as the entry and exit times. It can be used to reconstruct the sequence of event/ actions that happend in this task.
     * @summary Get task
     * @param {string} id Id of the device that owns the task.
     * @param {string} taskId Id of the task
     * @returns {Promise<DeviceConfigurationModels.ConfigurationTask>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetDeviceConfigurationTask("mdsp.EnvironmentDevice", "345af46...")
     * @memberOf DeviceConfigurationClient
     */
    GetDeviceConfigurationTask(id: string, taskId: string): Promise<DeviceConfigurationModels.ConfigurationTask>;
    /**
     * Create a new config deployment task.  # Start of Execution # The newly created task will be in the CREATED state and thus not visible to the device. In order to start the execution of the task, update it to the CONFIGURE state.  # Files # Each task refers to one or more files. Devices are expected to apply all files of a task in an \"atomic\" fashion (as far as this is feasible) The specified URI will be passed \"as-is\" to the device. Devices are expected to access this URI using Mindsphere credentials. Typically this URI will refer to a file in the Configuration File Storage, however it is possible to pass any URIs to the device as long as the device has the appropriate credentials to access the URI.  # CustomData #  The optional customData field can be used to pass arbitrary json data from the backend to the device in order. The backend will forward this information \"as-is\" to the device.
     * @summary Create new task
     * @param {string} id Id of the device that owns the task.
     * @param {DeviceConfigurationModels.TaskDefinition} taskDefinition task definition
     * @returns {Promise<DeviceConfigurationModels.ConfigurationTask>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await DeviceConfigurationClient.PostNewDeploymentTaskConfiguration("myDeviceID", ...)
     * @memberOf DeviceConfigurationClient
     */
    PostNewDeploymentTaskConfiguration(id: string, taskDefinition: DeviceConfigurationModels.TaskDefinition): Promise<DeviceConfigurationModels.ConfigurationTask>;
    /**
     * Updates the task.  Updates must follow the state machine definition. Failing to do so will cause a 409 error
     * @summary Update a task
     * @param {string} id Id of the device that owns the task.
     * @param {string} taskId Id of the task
     * @param {DeviceConfigurationModels.Updatetask} progressReport Updated configuration
     * @returns {Promise<DeviceConfigurationModels.ConfigurationTask>}
     *
     * @example await DeviceConfigurationClient.PatchDeploymentTaskConfiguration("myDeviceID", "mytaskID", ...)
     * @memberOf DeviceConfigurationClient
     */
    PatchDeploymentTaskConfiguration(id: string, taskId: string, progressReport: DeviceConfigurationModels.Updatetask): Promise<DeviceConfigurationModels.ConfigurationTask>;
    /**
     * Lists all files # Filtering / Searching # Using the `pathPrefix` query parameter, this endpoint can be used to  look up the ids of files with a given path prefix. The supplied prefix will be compared with the `path` field of the file metadata. Users of the API should pick a naming scheme that allows efficient searching of files, e.g., using `{id}/{filename}.json` allows efficient listing of all files \"belonging\" to a specific device id.
     * @summary List files
     * @param {string} pathPrefix the prefix to search for
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @param {string} [sort] The order in which the elements are returned. Multiple fields could be used spearated by comma
     * @returns {Promise<DeviceConfigurationModels.PaginatedFileMetaData>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetFiles("./myfile")
     * @memberof DeviceConfigurationClient
     */
    GetFiles(pathPrefix: string, size?: number, page?: number, sort?: string): Promise<DeviceConfigurationModels.PaginatedFileMetaData>;
    /**
     * Returns the metadata of the specified file. # File Id to Path Mapping # To obtain the id of a file, the GET `files` endpoint can be used which allows looking up file ids based on a path prefix  # File Metadata / File Content # This endpoint returns the metadata of the file. To access the content of the file, either use the `files/{id}/head` endpoint (to access the latest revision) or list all available revisions via  `files/{id}/revisions` and access the content of a specific revision via `files/{id}/revisions/{hash}/content`
     * @summary Get file metadata
     * @param {string} id the ID of the file
     * @returns {Promise<DeviceConfigurationModels.FileMetaData>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetFileMetadata("myFileID")
     * @memberOf DeviceConfigurationClient
     */
    GetFileMetadata(id: string): Promise<DeviceConfigurationModels.FileMetaData>;
    /**
     * Create a new config file. The specified path must be unique (see general documentation about paths)
     * @summary Create a new empty file
     * @param {DeviceConfigurationModels.ConfigurationFile} file configuration file object
     * @returns {Promise<DeviceConfigurationModels.FileMetaData>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await DeviceConfigurationClient.PostNewFile( ...)
     * @memberOf DeviceConfigurationClient
     */
    PostNewFile(file: DeviceConfigurationModels.ConfigurationFile): Promise<DeviceConfigurationModels.FileMetaData>;
    /**
     * Updates the \"head\" of this file, i.e., creates a new revision containing the data sent with the requests and updates the head resource to point to this new revision. Clients should use the If-Match header to safeguard against lost updates, i.e. concurrent access to the head resource  # Content Metadata #  Information about the content type and content length of the file are taken from the corresponding http header fields and must be correctly set by the client
     * @summary Update \"head\"
     * @param {string} id the ID of the file
     * @param {DeviceConfigurationModels.Payload} content Binary content of file.
     * @param {string} [contentType] Defines the accept header value to be used when retrieving the content
     * @returns {Promise<DeviceConfigurationModels.FileMetaData>}
     *
     * @example await DeviceConfigurationClient.PatchDeploymentTaskConfiguration("myFileID", ...)
     * @memberOf DeviceConfigurationClient
     */
    PatchFileHead(id: string, content: DeviceConfigurationModels.Payload, contentType?: string): Promise<DeviceConfigurationModels.FileMetaData>;
    /**
     * Deletes the specified file. This will also delete any revisions of this file and their content. # Idempotency # This endpoint provides idempotent deletes, i.e., repeated deletes to the same resource will always return 204 responses regardless whether the resource existed in the first place or not.
     * @summary Delete file
     * @param {string} id the ID of the file
     *
     * @example await DeviceConfigurationClient.DeleteFile("myFileID")
     *
     * @memberOf DeviceConfigurationClient
     */
    DeleteFile(id: string): Promise<void>;
    /**
     * Returns a paginated list of all revisions of the specified file. # File Metadata / File Content # This endpoint returns the metadata of the revision. To access the  content use the`files/{id}/revisions/{hash}/content` endpoint
     * @summary List revisions of a file
     * @param {string} id the ID of the file
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @param {string} [sort] The order in which the elements are returned. Multiple fields could be used spearated by comma
     * @returns {Promise<DeviceConfigurationModels.PaginatedRevisionMetaData>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetFileRevisions("myFileID")
     * @memberof DeviceConfigurationClient
     */
    GetFileRevisions(id: string, size?: number, page?: number, sort?: string): Promise<DeviceConfigurationModels.PaginatedRevisionMetaData>;
    /**
     * Returns the metadata of the specified file revision
     * @summary Get revision metadata
     * @param {string} id the ID of the file
     * @param {string} hash the hash, also serves as id of the revision
     * @returns {Promise<DeviceConfigurationModels.RevisionMetaData>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetFileMetadata("myFileID", "8ac80b...")
     * @memberOf DeviceConfigurationClient
     */
    GetFileRevisionMetadata(id: string, hash: string): Promise<DeviceConfigurationModels.RevisionMetaData>;
    /**
     * Returns the content of the specified file revision.
     * @summary Get revision content
     * @param {string} id the ID of the file
     * @param {string} hash the hash, also serves as id of the revision
     * @param {string} [accept] If provided, must equal Content-Type provided while uploading
     * @returns {Promise<DeviceConfigurationModels.Payload>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetFileRevisionContent("myFileID",...)
     * @memberOf DeviceConfigurationClient
     */
    GetFileRevisionContent(id: string, hash: string, accept?: string): Promise<DeviceConfigurationModels.Payload>;
    /**
     * Creates a new revision containing the provided content. This endpoint will not update the \"head\" of the file to point to the new revision. # Content Metadata #  Information about the content type and content length of the file are taken from the corresponding http header fields and must be correctly set by the client
     * @summary Create a new revision
     * @param {string} id the ID of the file
     * @param {Payload} content Binary content of file.
     * @param {string} [contentType] Defines the accept header value to be used when retrieving the content
     * @returns {Promise<DeviceConfigurationModels.RevisionMetaData>}
     * @throws {DeviceConfigurationModels.RequiredError}
     *
     * @example await DeviceConfigurationClient.PostFileRevision("myFileID", ...)
     * @memberOf DeviceConfigurationClient
     */
    PostFileRevision(id: string, content: DeviceConfigurationModels.Payload, contentType?: string): Promise<DeviceConfigurationModels.RevisionMetaData>;
}
/**
 * Deployment Workflow API
 * This API allows to create and execute reusable deployment worfklows for devices defined by Device Management. Each workflow is modeled as a state machine running in the backend, with tasks to be executed against devices. Examples of tasks are installation of firmware or other types of commands issued to  devices.  The API offers model resources to be used to set up workflow templates, which define possible workflow states and transistions between them. While device builders can define custom models, predefined models are available for default installation and removal tasks. Instance resources represent instantiated workflows and allow to trigger state transitions.  Only a subset of the operations in this API is meant for use by agents, defined in the following table.  | Path | Method | Audience | |--------|------|----------| | models | POST | Northbound | | models | GET | Northbound | | models | DELETE | Northbound | | instances | POST | Northbound | | instances | GET | Northbound, Southbound | | instances/{id} | GET | Northbound, Southbound | | instances/{id} | PATCH | Northbound, Southbound | | instances/{id}/cancel | POST | Northbound, Southbound |  Northbound: The term stands for interactive or technical users which initiate the request Southbound: The term stands for agents which initiate the request
 *
 * @export
 * @class DeploymentWorkflowClient
 * @extends {SdkClient}
 */
export declare class DeploymentWorkflowClient extends SdkClient {
    private _baseUrl;
    /**
     * Model description for a given key
     * @summary Model description for a given key
     * @param {string} modelKey Unique key for the model
     * @returns {Promise<DeploymentWorkflowModels.Model>}
     * @throws {DeploymentWorkflowModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetWorkflowModel( "345af46...")
     * @memberOf DeploymentWorkflowClient
     */
    GetWorkflowModel(modelKey: string): Promise<DeploymentWorkflowModels.Model>;
    /**
     * Add a new workflow model
     * @summary Add a new workflow model
     * @param {Model} model Workflow model object that needs to be added
     * @returns {Promise<DeploymentWorkflowModels.Model>}
     * @throws {DeploymentWorkflowModels.RequiredError}
     *
     * @example await DeploymentWorkflowClient.PostNewWorkflowModel(...)
     * @memberOf DeploymentWorkflowClient
     */
    PostNewWorkflowModel(model: DeploymentWorkflowModels.Model): Promise<DeploymentWorkflowModels.Model>;
    /**
     * Deletes a model with a given key
     * @summary Deletes a model with a given key
     * @param {string} modelKey Key for the model
     *
     * @example await DeploymentWorkflowClient.DeleteWorkflowModel("myModelKey")
     *
     * @memberOf DeploymentWorkflowClient
     */
    DeleteWorkflowModel(modelKey: string): Promise<void>;
    /**
     * List of instance descriptions belonging to the caller's tenant. By default, this endpoint returns the list of instances in a specific order and predetermined paging properties.  These defaults are:   - Hide model details.     Equivalent of query parameter modelDetails = flase   - Hide history     Equivalent of query parameter history = false   - Ascending sort on createdAt date   - 10 entries per page
     * @summary List of instance descriptions belonging to the caller's tenant
     * @param {boolean} [model] Boolean flag to include the model used for the instance
     * @param {boolean} [history] Boolean flag to include the transition history of the instance
     * @param {string} [currentState] Filter instances based on the current state value
     * @param {string} [group] Filter instances based on the state group they are in
     * @param {string} [deviceId] Filter instances belonging to a specific device with deviceId
     * @param {string} [modelKey] Filter instances that are created from a given key
     * @returns {Promise<DeploymentWorkflowModels.PaginatedFileMetaData>}
     * @throws {DeploymentWorkflowModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetModelInstances();
     * @memberof DeploymentWorkflowClient
     */
    GetWorkflowInstances(model?: boolean, history?: boolean, currentState?: string, group?: string, deviceId?: string, modelKey?: string): Promise<DeploymentWorkflowModels.PaginatedInstanceList>;
    /**
     * Instance description for a given id
     * @summary Instance description for a given id
     * @param {string} id Instance id
     * @param {boolean} [model] Boolean flag to include the model used for the instance
     * @param {boolean} [history] Boolean flag to include the transition history of the instance
     * @returns {Promise<DeploymentWorkflowModels.Instance>}
     * @throws {DeploymentWorkflowModels.RequiredError}
     *
     * @example await deviceConfigurationClient.GetWorkflowInstance("myInstanceId")
     * @memberOf DeploymentWorkflowClient
     */
    GetWorkflowInstance(id: string, model?: boolean, history?: boolean): Promise<DeploymentWorkflowModels.Instance>;
    /**
     * Add a new workflow instance
     * @summary Add a new workflow instance
     * @param {DeploymentWorkflowModels.InstanceRequest} workflowInstance Workflow instance that needs to be created
     * @param {boolean} [model] Boolean flag to include the model used for the instance
     * @param {boolean} [history] Boolean flag to include the transition history of the instance
     * @returns {Promise<DeploymentWorkflowModels.Instance>}
     * @throws {DeploymentWorkflowModels.RequiredError}
     *
     * @example await DeploymentWorkflowClient.PostNewWorflowInstance( ...)
     * @memberOf DeploymentWorkflowClient
     */
    PostNewWorflowInstance(workflowInstance: DeploymentWorkflowModels.InstanceRequest, model?: boolean, history?: boolean): Promise<DeploymentWorkflowModels.Instance>;
    /**
     * Modify current state of a workflow instance
     * @summary Modify current state of a workflow instance
     * @param {string} id Instance id
     * @param {StateInfo} stateInfo State to be used for advancing the workflow instance to. This is going to be used as progress report from devices or backend.
     * @param {boolean} [history] Boolean flag to include the transition history of the instance
     * @param {boolean} [model] Boolean flag to include the model of the instance in response
     * @param {string} [contentType] Defines the accept header value to be used when retrieving the content
     * @returns {Promise<DeploymentWorkflowModels.Instance>}
     *
     * @example await DeploymentWorkflowClient.PatchWorkflowInstance("myWorkflowId", ...)
     * @memberOf DeploymentWorkflowClient
     */
    PatchWorkflowInstance(id: string, stateInfo: DeploymentWorkflowModels.StateInfo, history?: boolean, model?: boolean): Promise<DeploymentWorkflowModels.Instance>;
    /**
     * Cancels the workflow instance if the transition from canceled to current state is defined and available
     * @summary Cancels the workflow instance if the transition from canceled to current state is defined and available
     * @param {string} id Instance id
     * @param {boolean} [history] Boolean flag to include the transition history of the instance
     * @param {boolean} [model] Boolean flag to include the model of the instance in response
     *
     * @example await DeploymentWorkflowClient.PostToCancelWorkflowInstance("myWorkflowID")
     *
     * @memberOf DeploymentWorkflowClient
     */
    PostToCancelWorkflowInstance(id: string, history?: boolean, model?: boolean): Promise<DeploymentWorkflowModels.Instance>;
}
/**
 * Edge App Instance Management API
 *  Edge App Instance Management API can be used to synchronize the edge application instance runtime lifecycle and applied configuration values. The provided operations do not realize the runtime or configuration changes directly to edge application instances. Instead, they are meant as a synchronization point for user-facing applications and applications realizing the changes.   Two resources are offered: application instances model the runtime lifecycle of an edge application instance. An edge application instance can be started or stopped. Instance configuration resources assign a configuration consisting of key-value pairs to an edge application instance running on a device. It is possible to assign individual configurations for different instances running on the same device.
 *
 * @export
 * @class EdgeAppInstanceManagementClient
 * @extends {SdkClient}
 */
export declare class EdgeAppInstanceManagementClient extends SdkClient {
    private _baseUrl;
    /**
     * Get application instance list by device id.
     * @summary Get application instance list by device id.
     * @param {string} deviceId ID of the device
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @param {string} [sort] The order in which the elements are returned. Multiple fields could be used spearated by comma
     * @returns {Promise<EdgeAppInstanceModels.PaginatedApplicationInstance>}
     * @throws {EdgeAppInstanceModels.RequiredError}
     *
     * @example await edgeAppInstanceManagementClient.GetAppInstances("mdsp.myDevice")
     * @memberof EdgeAppInstanceManagementClient
     */
    GetAppInstances(deviceId: string, size?: number, page?: number, sort?: string): Promise<EdgeAppInstanceModels.PaginatedApplicationInstance>;
    /**
     * Get the status of the application instance.
     * @summary Get the status of the application instance.
     * @param {string} id ID of the application instance
     * @returns {Promise<EdgeAppInstanceModels.ApplicationInstanceLifeCycleResource>}
     * @throws {EdgeAppInstanceModels.RequiredError}
     *
     * @example await edgeAppInstanceManagementClient.GetAppInstanceLifecycle("myAppInstanceID")
     * @memberOf EdgeAppInstanceManagementClient
     */
    GetAppInstanceLifecycle(id: string): Promise<EdgeAppInstanceModels.ApplicationInstanceLifeCycleResource>;
    /**
     * This endpoint allows deleting instance.
     * @summary Delete application instance.
     * @param {string} id ID of the application instance
     * @throws {EdgeAppInstanceModels.RequiredError}
     *
     * @example await edgeAppInstanceManagementClient.DeleteAppInstance("mdsp.EnvironmentDeviceAppInst")
     *
     * @memberOf EdgeAppInstanceManagementClient
     */
    DeleteAppInstance(id: string): Promise<void>;
    /**
     * Create application instance
     * @summary Create application instance.
     * @param {EdgeAppInstanceModels.ApplicationInstance} applicationInstance Application instance fields.
     * @returns {Promise<EdgeAppInstanceModels.ApplicationInstance>}
     *
     * @example await edgeAppInstanceManagementClient.PostAppInstance(myAppInstanceData)
     * @memberOf EdgeAppInstanceManagementClient
     */
    PostAppInstance(applicationInstance: EdgeAppInstanceModels.ApplicationInstance): Promise<EdgeAppInstanceModels.ApplicationInstanceResource>;
    /**
     * Update status of the application instance.
     * @summary Set Status of Application Release Instance.
     * @param {string} id ID of the application instance
     * @param {EdgeAppInstanceModels.ApplicationInstanceLifeCycleStatus} applicationInstanceStatus Application instance status fields.
     * @returns {Promise<EdgeAppInstanceModels.ApplicationInstanceLifeCycleResource>}
     *
     * @example await edgeAppInstanceManagementClient.PatchAppInstanceStatus("mdsp.EnvironmentDeviceAppInst", myNewAppStatusData)
     * @memberOf EdgeAppInstanceManagementClient
     */
    PatchAppInstanceStatus(id: string, applicationInstanceStatus: EdgeAppInstanceModels.ApplicationInstanceLifeCycleStatus): Promise<EdgeAppInstanceModels.ApplicationInstanceLifeCycleResource>;
    /**
     * Get all instance configurations by deviceId.
     * @summary Get Instance Configurations for a specific device
     * @param {string} deviceId ID of the device
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @param {string} [sort] The order in which the elements are returned. Multiple fields could be used spearated by comma
     * @returns {Promise<EdgeAppInstanceModels.PaginatedInstanceConfigurationResource>}
     * @throws {EdgeAppInstanceModels.RequiredError}
     *
     * @example await edgeAppInstanceManagementClient.GetAppInstanceConfigurations("mdsp.EnvironmentDevice")
     * @memberof EdgeAppInstanceManagementClient
     */
    GetAppInstanceConfigurations(deviceId: string, size?: number, page?: number, sort?: string): Promise<EdgeAppInstanceModels.PaginatedInstanceConfigurationResource>;
    /**
     * Get an instance configuration by id.
     * @summary Get Instance Configuration
     * @param {string} id ID of the application instance
     * @returns {Promise<EdgeAppInstanceModels.InstanceConfigurationResource>}
     * @throws {EdgeAppInstanceModels.RequiredError}
     *
     * @example await edgeAppInstanceManagementClient.GetAppInstanceConfiguration("myAppInstanceConfiguration")
     * @memberOf EdgeAppInstanceManagementClient
     */
    GetAppInstanceConfiguration(id: string): Promise<EdgeAppInstanceModels.InstanceConfigurationResource>;
    /**
     * Deletes an instance configuration.
     * @summary Delete Instance Configuration
     * @param {string} id ID of the application instance
     * @throws {EdgeAppInstanceModels.RequiredError}
     *
     * @example await edgeAppInstanceManagementClient.DeleteAppInstanceConfiguration("mdsp.EnvironmentDeviceAppConf")
     *
     * @memberOf EdgeAppInstanceManagementClient
     */
    DeleteAppInstanceConfiguration(id: string): Promise<void>;
    /**
     * Creates a new instance configuration for the given device id and application instance id with the given content.
     * @summary Create instance configuration
     * @param {EdgeAppInstanceModels.InstanceConfiguration} instanceConfiguration Instance configuration object
     * @returns {Promise<EdgeAppInstanceModels.InstanceConfigurationResource>}
     *
     * @example await edgeAppInstanceManagementClient.PostAppInstanceConfigurations(myAppInstanceConfiguration)
     * @memberOf EdgeAppInstanceManagementClient
     */
    PostAppInstanceConfigurations(instanceConfiguration: EdgeAppInstanceModels.InstanceConfiguration): Promise<EdgeAppInstanceModels.InstanceConfigurationResource>;
    /**
     * Patch update for the instance configurations. The list length can be maximum 100.
     * @summary Processes instance configuration
     * @param {EdgeAppInstanceModels.ProcessInstanceConfiguration} configurations List of configuration per instance
     *
     * @example await edgeAppInstanceManagementClient.PatchAppInstanceConfigurations(myNewAppInstanceConfiguration)
     * @memberOf EdgeAppInstanceManagementClient
     */
    PatchAppInstanceConfigurations(configurations: EdgeAppInstanceModels.ProcessInstanceConfiguration): Promise<void>;
    /**
     * Updates the specified instance configuration.
     * @summary Update Configuration Data
     * @param {string} id ID of the application instance
     * @param {EdgeAppInstanceModels.InstanceConfiguration} instanceConfiguration Configuration Content
     * @returns {Promise<EdgeAppInstanceModels.InstanceConfigurationResource>}
     *
     * @example await edgeAppInstanceManagementClient.PatchAppInstanceConfigurationData("mdsp.EnvironmentDeviceAppConf", myNewConfigurationData)
     * @memberOf EdgeAppInstanceManagementClient
     */
    PatchAppInstanceConfigurationData(id: string, instanceConfiguration: EdgeAppInstanceModels.InstanceConfiguration): Promise<EdgeAppInstanceModels.InstanceConfigurationResource>;
}
/**
 * Edge App Deployment API
 *  Edge App Deployment API helps to coordinate installation and removal of edge applications to and from devices. The provided operations do not trigger any actions themselves, but are meant to be used by northbound applications to coordinate user and device efforts. Installation or removal tasks consist of different states that require the app user and the target device to participate in order to complete a task.   Devices can not use this API to participate in installation or removal tasks. Instead, devices must use the Deployment Workflow API. Edge App Deployment Service is based on Deployment Workflow Service and reflects all changes applied through Deployment Workflow API. Once a task is created in this API, it will be available also through Deployment Workflow API.   In order to be able to create an installation task, users first need to accept the terms and conditions for a specific device and application release ID. For this purpose, applications must present the corresponding terms and conditions to a user and forward the user's acceptance to this API.
 *
 * @export
 * @class EdgeAppDeploymentClient
 * @extends {SdkClient}
 */
export declare class EdgeAppDeploymentClient extends SdkClient {
    private _baseUrl;
    /**
     * Returns a paginated list of all installation tasks for the given device id ordered in descending order of creation date (newest tasks first).
     * @summary List installation tasks for a device
     * @param {string} deviceId ID of the device
     * @param {'closed' | 'open'} [status] Task status (closed tasks are tasks in ACTIVATED, CANCELED or FAILED states, open are all other)
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @param {string} [sort] The order in which the elements are returned. Multiple fields could be used spearated by comma
     * @returns {Promise<EdgeAppDeploymentModels.PaginatedTaskResource>}
     * @throws {EdgeAppDeploymentModels.RequiredError}
     *
     * @example await edgeAppDeploymentClient.GetInstallationTasks("mdsp.myDevice");
     * @memberof EdgeAppDeploymentClient
     */
    GetInstallationTasks(deviceId: string, status?: "closed" | "open", size?: number, page?: number, sort?: string): Promise<EdgeAppDeploymentModels.PaginatedTaskResource>;
    /**
     * Returns an installation task by id.
     * @summary Get an installation task
     * @param {string} id ID of the task
     * @returns {Promise<EdgeAppDeploymentModels.TaskResource>}
     * @throws {EdgeAppDeploymentModels.RequiredError}
     *
     * @example await edgeAppDeploymentClient.GetAppInstanceLifecycle("myAppInstanceID")
     * @memberOf EdgeAppDeploymentClient
     */
    GetInstallationTask(id: string): Promise<EdgeAppDeploymentModels.TaskResource>;
    /**
     * Creates a new installation task for the specified software release. The newly created task can be monitored and controlled using the Task Control API.  # Constraints # This endpoint performs a lot of consistency checks. * All ids must refer to existing entities.  * The referenced software release must be compatible with the device.  It is possible to create an installation task for a software already installed on the device. It is dependent on the device implementation what will happen in this case. Devices may re-install the software or cancel / abort the task with an error message.  # Task Execution #  Tasks created via this endpoint are executed in a fire&forget fashion. Execution will start immediately after creation and will run without further user interaction. Progress monitoring is however available via the Task Control API.
     * @summary Create installation task for an application release to a device
     * @param {EdgeAppDeploymentModels.Task} task Content of the installation task
     * @returns {Promise<EdgeAppDeploymentModels.TaskResource>}
     *
     * @example await edgeAppDeploymentClient.PostInstallationTask(...)
     * @memberOf EdgeAppDeploymentClient
     */
    PostInstallationTask(task: EdgeAppDeploymentModels.Task): Promise<EdgeAppDeploymentModels.TaskResource>;
    /**
     * Updates the installation task specified by the given device and task id. This endpoint should be used to perform backend triggered state transitions by advancing the task to the desired target state. # State Machine # The task system uses a state machine to synchronize the state of the device with the state of the backend (see general documentation for more details). All task updates must adhere to the state machine defined in the task. Failing to do so will cause a 409 Conflict error.
     * @summary Update an installation task
     * @param {string} id ID of the task
     * @param {EdgeAppDeploymentModels.TaskStatus} status Content of the task status
     * @returns {Promise<EdgeAppDeploymentModels.TaskResource>}
     *
     * @example await edgeAppDeploymentClient.PatchInstallationTask("myTaskID", myTaskStatus)
     * @memberOf EdgeAppDeploymentClient
     */
    PatchInstallationTask(id: string, status: EdgeAppDeploymentModels.TaskStatus): Promise<EdgeAppDeploymentModels.TaskResource>;
    /**
     * Returns a paginated list of all removal tasks for the given device id ordered in descending order of creation date (newest tasks first).
     * @summary List removal tasks for a device
     * @param {string} deviceId ID of the device
     * @param {'closed' | 'open'} [status] Task status (closed tasks are tasks in ACTIVATED, CANCELED or FAILED states, open are all other)
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @param {string} [sort] The order in which the elements are returned. Multiple fields could be used spearated by comma
     * @returns {Promise<EdgeAppDeploymentModels.PaginatedTaskResource>}
     * @throws {EdgeAppDeploymentModels.RequiredError}
     *
     * @example await edgeAppDeploymentClient.GetRemovalTasks("mdsp.EnvironmentDevice")
     * @memberof EdgeAppDeploymentClient
     */
    GetRemovalTasks(deviceId: string, status?: "closed" | "open", size?: number, page?: number, sort?: string): Promise<EdgeAppDeploymentModels.PaginatedTaskResource>;
    /**
     * Creates a new removal task for the specified software release. The newly created task can be monitored and controlled using the Task Control API.  # Constraints # This endpoint performs a lot of consistency checks. * All ids must refer to existing entities.  * The referenced software release must be compatible with the device.  # Task Execution #  Tasks created via this endpoint are executed in a fire&forget fashion. Execution will start immediately after creation and will run without further user interaction. Progress monitoring is however available via the Task Control API.
     * @summary Create removal task for an application release to a device
     * @param {EdgeAppDeploymentModels.Task} task Content of the removal task
     * @returns {Promise<EdgeAppDeploymentModels.TaskRessource>}
     *
     * @example await edgeAppDeploymentClient.PostRemovalTask(myRemovalTask)
     * @memberOf EdgeAppDeploymentClient
     */
    PostRemovalTask(task: EdgeAppDeploymentModels.Task): Promise<EdgeAppDeploymentModels.TaskResource>;
    /**
     * Checks whether terms and conditions have been accepted for a specific device and release.
     * @summary Check acceptance of terms and conditions
     * @param {string} deviceId ID of the device
     * @param {string} releaseId ID of the application release
     * @returns {Promise<EdgeAppDeploymentModels.TermsAndConditionsResource>}
     * @throws {EdgeAppDeploymentModels.RequiredError}
     *
     * @example await edgeAppDeploymentClient.GetTermsAndConditions("mdsp.EnvironmentDevice", "V001");
     * @memberof EdgeAppDeploymentClient
     */
    GetTermsAndConditions(deviceId: string, releaseId: string): Promise<EdgeAppDeploymentModels.TermsAndConditionsResource>;
    /**
     * Accepts terms and conditions for a specific device and release. Has no effect if the terms and conditions have already been accepted earlier.
     * @summary Accept terms and conditions
     * @param {EdgeAppDeploymentModels.TermsAndConditions} termsandconditions acceptance notification
     * @returns {Promise<EdgeAppDeploymentModels.TaskRessource>}
     *
     * @example await edgeAppDeploymentClient.PostAcceptTermsAndConditions(mytermsandconditions)
     * @memberOf EdgeAppDeploymentClient
     */
    PostAcceptTermsAndConditions(termsandconditions: EdgeAppDeploymentModels.TermsAndConditions): Promise<EdgeAppDeploymentModels.TermsAndConditionsResource>;
}
/**
 * Firmware Deployment API
 * Firmware Deployment API helps to coordinate installation of firmware to devices. The provided operations do not trigger any actions themselves, but are meant to be used by northbound applications to coordinate user and device efforts. Installation tasks consist of different states that require the app user and the target device to participate in order to complete a task.   Devices cannot use this API to participate in installation tasks. Instead, devices must use the Deployment Workflow API. Firmware Deployment Service is based on Deployment Workflow Service and reflects all changes applied through Deployment Workflow API. Once a task is created in this API, it will be available also through Deployment Workflow API.   In order to be able to create an installation task, users first need to accept the terms and conditions for a specific device and firmware release ID. For this purpose, applications must present the corresponding terms and conditions to a user and forward the user's acceptance to this API.
 *
 * @export
 * @class FirmwareDeploymentClient
 * @extends {SdkClient}
 */
export declare class FirmwareDeploymentClient extends SdkClient {
    private _baseUrl;
    /**
     * Returns a paginated list of all installation tasks for the given device id ordered in descending order of creation date (newest task first). Convenience method, equivalent to /search?deviceId={deviceId} It is possible to create an installation task for a software already installed on the device. It is dependent on the device implementation what will happen in this case. Devices may re-install the software or cancel / abort the task with an error message.  # Filter Criteria # Filter criteria can be specified as query parameters. Supported parameters are * *type*: filter for tasks of a specific type (firmware, app, etc) * *status*: filter based on task progress, one of \"closed\" or \"open\" (closed tasks are tasks in ACTIVATED, CANCELED or FAILED states, open are all other)
     * @summary Lists installation tasks for a device.
     * @param {string} deviceId id of the device
     * @param {string} [type] Task Type
     * @param {'closed' | 'open'} [status] Task status
     * @param {number} [size] The maximum number of elements returned in one page
     * @param {number} [page] The (0-based) index of the page
     * @param {boolean} [history] Show task history
     * @returns {Promise<FirmwareDeploymentModels.PaginatedInstallationTask>}
     * @throws {FirmwareDeploymentModels.RequiredError}
     *
     * @example await firmwareDeploymentClient.GetInstallationTasks("mdsp.myDevice");
     * @memberof FirmwreDeploymentClient
     */
    GetInstallationTasks(deviceId: string, type?: string, status?: "closed" | "open", size?: number, page?: number, sort?: string, history?: boolean): Promise<FirmwareDeploymentModels.PaginatedInstallationTask>;
    /**
     * Returns a task by id.
     * @summary Get installation task.
     * @param {string} id id of the task
     * @param {boolean} [history] Show task history
     * @returns {Promise<FirmwareDeploymentModels.TaskResource>}
     * @throws {FirmwareDeploymentModels.RequiredError}
     *
     * @example await firmwareDeploymentClient.GetInstallationTask("myAppInstanceID")
     * @memberOf FirmwreDeploymentClient
     */
    GetInstallationTask(id: string, history?: boolean): Promise<FirmwareDeploymentModels.InstallationTask>;
    /**
     * Creates a new deployment task for the specified software release. The newly created task can be monitored and controlled  # Constraints #  This endpoint performs a lot of consistency checks.  * All ids must refer to existing entities. * The referenced software release must be compatible with the device.  It is possible to create an installation task for a software already installed on the device. It is dependent on the device implementation what will happen in this case. Devices may re-install the software or cancel / abort the task with an error message.   # Task Execution #  Tasks created via this endpoint are executed in a fire&forget fashion. Execution will start immediately after creation and will run without further user interaction. Progress monitoring is however available.
     * @summary Deploy firmware release to device.
     * @param {InstallationTaskInfo} taskDefinition content of the new task
     * @returns {Promise<FirmwareDeploymentModels.InstallationTask>}
     *
     * @example await firmwareDeploymentClient.PostInstallationTask(...)
     * @memberOf FirmwreDeploymentClient
     */
    PostInstallationTask(taskDefinition: FirmwareDeploymentModels.InstallationTaskInfo): Promise<FirmwareDeploymentModels.InstallationTask>;
    /**
     * Updates the task specified by the given device and task id. This endpoint should be used to perform backend triggered state transitions by advancing the task to the desired target state.  # State Machine # The task system uses a state machine to synchronize the state of the device with the state of the backend (see general documentation for more details). All task updates must adhere to the state machine defined in the task. Failing to do so will cause a 409 Conflict error.
     * @summary Update installation task.
     * @param {string} id id of the task
     * @param {FirmwareDeploymentModels.TaskUpdate} updateTaskInfo update message
     * @param {boolean} [history] Show task history
     * @returns {Promise<FirmwareDeploymentModels.TaskResource>}
     *
     * @example await firmwareDeploymentClient.PatchInstallationTask("myTaskID", myTaskStatus)
     * @memberOf FirmwreDeploymentClient
     */
    PatchInstallationTask(id: string, updateTaskInfo: FirmwareDeploymentModels.TaskUpdate, history?: boolean): Promise<FirmwareDeploymentModels.InstallationTask>;
    /**
     * Checks whether terms and conditions have been accepted for a specific device and release
     * @summary Check acceptance of terms and conditions
     * @param {string} deviceId id of the device
     * @param {string} releaseId releaseId
     * @returns {Promise<FirmwareDeploymentModels.TermsAndConditionsRecord>}
     * @throws {FirmwareDeploymentModels.RequiredError}
     *
     * @example await firmwareDeploymentClient.GetTermsAndConditions("mdsp.EnvironmentDevice", "V001");
     * @memberof FirmwreDeploymentClient
     */
    GetTermsAndConditions(deviceId: string, releaseId: string): Promise<FirmwareDeploymentModels.TermsAndConditionsRecord>;
    /**
     * Accepts terms and conditions for a specific device and release.  Has no effect if the terms and conditions have already been accepted earlier
     * @summary Accept terms and conditions
     * @param {FirmwareDeploymentModels.TermsAndConditionsAcceptance} acceptance acceptance notification
     * @returns {Promise<FirmwareDeploymentModels.TermsAndConditionsRecord>}
     *
     * @example await firmwareDeploymentClient.PostAcceptTermsAndConditions(mytermsandconditions)
     * @memberOf FirmwreDeploymentClient
     */
    PostAcceptTermsAndConditions(acceptance: FirmwareDeploymentModels.TermsAndConditionsAcceptance): Promise<FirmwareDeploymentModels.TermsAndConditionsRecord>;
}
