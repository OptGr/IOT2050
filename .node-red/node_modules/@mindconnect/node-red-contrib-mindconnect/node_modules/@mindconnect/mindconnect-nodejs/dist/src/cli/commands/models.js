"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.listModels = void 0;
const console_1 = require("console");
const fs = require("fs");
const path = require("path");
const util = require("util");
const uuid = require("uuid");
const utils_1 = require("../../api/utils");
const command_utils_1 = require("./command-utils");
const mime = require("mime-types");
const streamPipeline = util.promisify(require("stream").pipeline);
let color = (0, command_utils_1.getColor)("blue");
exports.default = (program) => {
    program
        .command("models")
        .alias("ml")
        .option("-m, --mode [list|create|delete|update|info|download|template]", "mode [list | create | delete | update | info | download| template]", "list")
        .option("-n, --modelname <modelname>", "modelname")
        .option("-t, --modeltype <modeltype>", "modeltype")
        .option("-d, --modeldesc <modeldesc>", "modeldesc", "created with mindsphere CLI")
        .option("-i, --modelid <modelid>", "mindsphere model id ")
        .option("-f, --metadata <metadata>", "model metadata file", "model.metadata.mdsp.json")
        .option("-r, --version <version>", "model version for download", "last")
        .option("-p, --payload <payload>", "model payload file", "model.payload.mdsp.json")
        .option("-i, --modelid <modelid>", "mindsphere model id ")
        .option("-a, --modelauthor <modelauthor>", "model author", "created by mindsphere CLI")
        .option("-k, --passkey <passkey>", "passkey")
        .option("-y, --retry <number>", "retry attempts before giving up", "3")
        .option("-v, --verbose", "verbose output")
        .description(color(`list, create or delete analytic models *`))
        .action((options) => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                checkRequiredParameters(options);
                const sdk = (0, command_utils_1.getSdk)(options);
                color = (0, command_utils_1.adjustColor)(color, options, true);
                (0, command_utils_1.homeDirLog)(options.verbose, color);
                (0, command_utils_1.proxyLog)(options.verbose, color);
                switch (options.mode) {
                    case "template":
                        yield createTemplate(options, sdk);
                        console.log("Edit the files before submitting them to mindsphere.");
                        break;
                    case "create":
                        yield createModel(options, sdk);
                        break;
                    case "list":
                        yield listModels(options, sdk);
                        break;
                    case "delete":
                        yield deleteModel(options, sdk);
                        break;
                    case "update":
                        yield updateModel(options, sdk);
                        break;
                    case "info":
                        yield modelInfo(options, sdk);
                        break;
                    case "download":
                        yield downloadModel(options, sdk);
                        break;
                    default:
                        throw Error(`no such option: ${options.mode}`);
                }
            }
            catch (err) {
                (0, command_utils_1.errorLog)(err, options.verbose);
            }
        }))();
    })
        .on("--help", () => printHelp());
};
function printHelp() {
    (0, console_1.log)("\n  Examples:\n");
    (0, console_1.log)(`    mc models --mode template --modeltype core.basicmodel --modelname MyModel \t creates a template for model`);
    (0, console_1.log)(`    mc models --mode create --metadata model.metadata.mdsp.json --payload model.payload.mdsp.json \n\t\t\t\t\t\t\t creates a model from specified files`);
    (0, console_1.log)(`    mc models --mode list \t\t\t\t lists all models in mindsphere`);
    (0, console_1.log)(`    mc models --mode delete --modelid 1234567..ef \t deletes model with specified id`);
    (0, console_1.log)(`    mc models --mode info --modelid 123456...ef \t print out infos about model with id 132456...ef`);
    (0, console_1.log)(`    mc models --mode download --modelid 123456...ef \t download model with id 132456...ef`);
    (0, command_utils_1.serviceCredentialLog)();
}
function listModels(options, sdk) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const modelMgmt = sdk.GetModelManagementClient();
        let page = 0;
        let models;
        console.log(`modelid  name  [type]  author  version`);
        let modelCount = 0;
        do {
            models = (yield (0, utils_1.retry)(options.retry, () => modelMgmt.GetModels({
                pageNumber: page,
                pageSize: 100,
                sort: "asc",
            })));
            models.models = models.models || [];
            models.page = models.page || { totalPages: 0 };
            for (const model of models.models || []) {
                modelCount++;
                console.log(`${model.id}  ${color(model.name)}\t${model.type}\t[${model.author}]\t${(_a = model.lastVersion) === null || _a === void 0 ? void 0 : _a.number}`);
                (0, command_utils_1.verboseLog)(JSON.stringify(model, null, 2), options.verbose);
            }
        } while (page++ < (models.page.totalPages || 0));
        console.log(`${color(modelCount)} models listed.\n`);
    });
}
exports.listModels = listModels;
function updateModel(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const tenant = sdk.GetTenant();
        const modelMgmt = sdk.GetModelManagementClient();
        const oModel = (yield (0, utils_1.retry)(options.retry, () => modelMgmt.GetModel(options.modelid)));
        (0, command_utils_1.verboseLog)(JSON.stringify(oModel, null, 2), options.verbose);
        const type = options.modeltype ? options.modeltype : oModel.type || `${tenant}.CLI`;
        const patch = {
            name: options.modelname || oModel.name,
            type: type,
            description: options.modeldesc || oModel.description,
        };
        const nextModel = (yield (0, utils_1.retry)(options.retry, () => modelMgmt.PatchModel(`${oModel.id}`, patch)));
        console.log(`Model with modelid ${color(nextModel.id)} (${color(nextModel.name)}) have been patched.`);
    });
}
function createTemplate(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const metadata = {
            name: options.modelname || `unnamed model (${uuid.v4()})`,
            type: options.modeltype || "core.basicmodel",
            description: options.modeldesc || "created with mindsphere CLI",
            lastVersion: {
                number: 1.0,
                dependencies: [
                    {
                        name: "sklearn-theano",
                        type: "Python",
                        version: "2.7",
                    },
                ],
                io: {
                    consumes: "CSV",
                    input: [
                        {
                            name: "variablename1",
                            type: "integer",
                            description: "description for variablename1",
                            value: 5,
                        },
                    ],
                    output: [
                        {
                            name: "outputname1",
                            type: "integer",
                            description: "description for outputname1",
                            value: 3,
                        },
                    ],
                    optionalParameters: {
                        freeFormParams: "for the author to use",
                        param1: "value1",
                    },
                },
                producedBy: [],
                kpi: [
                    {
                        name: "error rate",
                        value: 0.9,
                    },
                ],
            },
        };
        const fileName = options.metadata || "model.metadata.mdsp.json";
        fs.writeFileSync(fileName, JSON.stringify(metadata, null, 2));
        const payloadFile = options.payload || "model.payload.mdsp.json";
        fs.writeFileSync(payloadFile, JSON.stringify({ empty: "model" }, null, 2));
        console.log(`The model metadata was written into ${color(fileName)} and empty model file ${color(payloadFile)} was created.\nRun \n\n\tmc models --mode create --metadata ${fileName} --payload ${payloadFile} \n\nto create the model.`);
    });
}
function createModel(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const modelMgmt = sdk.GetModelManagementClient();
        const filePath = path.resolve(options.metadata);
        const filecontent = fs.readFileSync(filePath);
        const filedata = JSON.parse(filecontent.toString());
        const payloadFullPath = path.resolve(options.payload);
        const filename = path.basename(payloadFullPath);
        const buff = fs.readFileSync(payloadFullPath);
        const mimetype = getFileType(options.payload);
        const result = (yield (0, utils_1.retry)(options.retry, () => __awaiter(this, void 0, void 0, function* () { return modelMgmt.PostModel(filedata, { buffer: buff, fileName: filename, mimeType: mimetype }); })));
        console.log(`Model with modelid ${color(result.id)} and name ${color(result.name)} was created.`);
    });
}
function deleteModel(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const modelMgmt = sdk.GetModelManagementClient();
        const model = yield (0, utils_1.retry)(options.retry, () => modelMgmt.GetModel(options.modelid));
        (0, command_utils_1.verboseLog)(JSON.stringify(model, null, 2), options.verbose);
        yield (0, utils_1.retry)(options.retry, () => modelMgmt.DeleteModel(options.modelid));
        console.log(`Model with modelid ${color(model.id)} (${color(model.name)}) was deleted.`);
    });
}
function modelInfo(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const model = (yield (0, utils_1.retry)(options.retry, () => sdk.GetModelManagementClient().GetModel(options.modelid)));
        (0, command_utils_1.verboseLog)(JSON.stringify(model, null, 2), options.verbose);
        const versions = (yield (0, utils_1.retry)(options.retry, () => sdk.GetModelManagementClient().GetModelVersions({ modelId: model.id, pageNumber: 0, pageSize: 100 })));
        printModel(model);
        printLatestModelVersions(versions);
    });
}
function downloadModel(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const metaDataPath = path.resolve(options.metadata);
        fs.existsSync(metaDataPath) && (0, command_utils_1.errorLog)(`the metadata file ${metaDataPath} already exists!`, true);
        const payloadPath = path.resolve(options.payload);
        fs.existsSync(payloadPath) && (0, command_utils_1.errorLog)(`the payload file ${payloadPath} already exists!`, true);
        const version = options.version || "last";
        const metadata = (yield (0, utils_1.retry)(options.retry, () => sdk.GetModelManagementClient().GetModelVersion(options.modelid, version)));
        (0, command_utils_1.verboseLog)(JSON.stringify(metadata, null, 2), options.verbose);
        fs.writeFileSync(metaDataPath, JSON.stringify(metadata, null, 2));
        console.log(`metadata file ${color(metaDataPath)} was written successfully.`);
        const download = (yield (0, utils_1.retry)(options.retry, () => sdk.GetModelManagementClient().DownloadModelVersion(options.modelid, version)));
        !download.ok && (0, command_utils_1.errorLog)(`Unexpected response ${download.statusText}`, true);
        const file = fs.createWriteStream(payloadPath);
        yield streamPipeline(download.body, file);
        console.log(`payload file ${color(payloadPath)} was written successfully.`);
    });
}
function checkRequiredParameters(options) {
    options.mode === "create" && !options.metadata && (0, command_utils_1.errorLog)("you have to specify the metadata file", true);
    options.mode === "create" && !options.payload && (0, command_utils_1.errorLog)("you have to specify the payload file", true);
    (options.mode === "delete" || options.mode === "update") &&
        !options.modelid &&
        (0, command_utils_1.errorLog)("you have to specify the id of the model", true);
    options.mode === "update" &&
        !options.modelname &&
        (0, command_utils_1.errorLog)("you have to specify at least the model name before patching the model", true);
    options.mode === "info" && !options.modelid && (0, command_utils_1.errorLog)("you have to provide a modelid", true);
    options.mode === "download" &&
        (!options.modelid || !options.metadata || !options.payload) &&
        (0, command_utils_1.errorLog)("you have to provide a modelid, metadata and payload file for download command", true);
}
function getFileType(metadata) {
    return metadata instanceof Buffer
        ? "application/octet-stream"
        : `${mime.lookup(metadata)}` || "application/octet-stream";
}
function printModel(model) {
    var _a, _b, _c, _d, _e, _f;
    console.log(`\nModel Information for Model with Model Id: ${color(model.id)}\n`);
    console.log(`Id: ${color(model.id)}`);
    console.log(`Name: ${color(model.name)}`);
    console.log(`Type: ${color(model.type)} ${color(":")} ${color((_a = model.lastVersion) === null || _a === void 0 ? void 0 : _a.number)}`);
    console.log(`Author: ${color(model.author)}`);
    console.log(`Description: ${color(model.description)}`);
    console.log("Last version:");
    console.log(`- Id: ${color((_b = model.lastVersion) === null || _b === void 0 ? void 0 : _b.id)}`);
    console.log(`- Version number: ${color((_c = model.lastVersion) === null || _c === void 0 ? void 0 : _c.number)}`);
    console.log(`- Author: ${color((_d = model.lastVersion) === null || _d === void 0 ? void 0 : _d.author)}`);
    console.log(`- Creation date: ${color((_e = model.lastVersion) === null || _e === void 0 ? void 0 : _e.creationDate)}`);
    console.log(`- Expiration date: ${color((_f = model.lastVersion) === null || _f === void 0 ? void 0 : _f.expirationDate)}`);
}
function printLatestModelVersions(versions) {
    var _a;
    console.log("\nLastest version entries:");
    console.table(((_a = versions.versions) === null || _a === void 0 ? void 0 : _a.slice(0, 5)) || [], ["number", "author", "creationDate", "expirationDate"]);
}
//# sourceMappingURL=models.js.map