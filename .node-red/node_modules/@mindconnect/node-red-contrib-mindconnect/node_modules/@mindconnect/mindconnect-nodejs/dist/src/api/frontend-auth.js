"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrontendAuth = void 0;
const cross_fetch_1 = require("cross-fetch");
const mindconnect_base_1 = require("./mindconnect-base");
const utils_1 = require("./utils");
function log(message) {
    if (typeof window !== "undefined" && window.DEBUGSDK === true) {
        console.log(message);
    }
}
/**
 *  Frontend Auth for Backend (only used from CLI)
 *
 * @export
 * @class BrowserAuth
 * @implements {TokenRotation}
 */
class FrontendAuth extends mindconnect_base_1.MindConnectBase {
    constructor(_gateway = "", _sesionCookie, _xsrfToken) {
        super();
        this._gateway = _gateway;
        this._sesionCookie = _sesionCookie;
        this._xsrfToken = _xsrfToken;
    }
    /**
     * perform http action
     *
     * @param {({
     *         verb: "GET" | "POST" | "PATCH" | "PUT" | "DELETE";
     *         gateway: string;
     *         baseUrl: string;
     *         authorization: string;
     *         body?: Object;
     *         message?: string;
     *         octetStream?: boolean;
     *         multiPartFormData?: boolean;
     *         additionalHeaders?: Object;
     *         noResponse?: boolean;
     *         rawResponse?: boolean;
     *         returnHeaders?: boolean;
     *         ignoreCodes?: number[];
     *     })} {
     *         verb,
     *         gateway,
     *         baseUrl,
     *         authorization,
     *         body,
     *         message,
     *         octetStream,
     *         multiPartFormData,
     *         additionalHeaders,
     *         noResponse,
     *         rawResponse,
     *         returnHeaders,
     *         ignoreCodes,
     *     }
     * @returns {Promise<Object>}
     *
     * @memberOf MindConnectBase
     */
    HttpAction({ verb, gateway, baseUrl, authorization, body, message, octetStream, multiPartFormData, additionalHeaders, noResponse, rawResponse, returnHeaders, ignoreCodes, }) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders = additionalHeaders || {};
            let apiheaders = octetStream ? this._octetStreamHeaders : this._apiHeaders;
            apiheaders = multiPartFormData ? this._multipartFormData : apiheaders;
            ignoreCodes = ignoreCodes || [];
            let headers = Object.assign({}, apiheaders);
            if (verb === "GET" || verb === "DELETE") {
                delete headers["Content-Type"];
            }
            // this is only used in commands when working with browser authorization
            if (this._sesionCookie && this._xsrfToken) {
                headers["cookie"] = `SESSION=${this._sesionCookie}; XSRF-TOKEN=${this._xsrfToken}`;
            }
            const xsrfTokenFromCookie = this._xsrfToken || this.getCookieValue("XSRF-TOKEN");
            if (xsrfTokenFromCookie && xsrfTokenFromCookie !== "") {
                headers["x-xsrf-token"] = xsrfTokenFromCookie;
                log(`Set x-xsrf-token to ${headers["x-xsrf-token"]}`);
            }
            else {
                log("There is no XSRF-TOKEN cookie.");
            }
            headers = (0, utils_1.removeUndefined)(Object.assign(Object.assign({}, headers), additionalHeaders));
            const url = this.isNodeOrCliCall() ? `${gateway}${baseUrl}` : `${baseUrl}`;
            log(`${message || ""} Headers ${JSON.stringify(headers)} Url ${url}`);
            try {
                const request = {
                    method: verb,
                    headers: headers,
                    credentials: "include",
                    agent: this._proxyHttpAgent,
                };
                if (verb !== "GET" && verb !== "DELETE") {
                    request.body = octetStream || multiPartFormData ? body : JSON.stringify(body);
                }
                const response = yield (0, cross_fetch_1.default)(url, request);
                const codeIgnored = ignoreCodes.indexOf(response.status) >= 0;
                !codeIgnored && !response.ok && (0, utils_1.throwError)(`${response.statusText} ${yield response.text()}`);
                !codeIgnored &&
                    (response.status < 200 || response.status > 299) &&
                    (0, utils_1.throwError)(`invalid response ${JSON.stringify(response)}`);
                if (codeIgnored)
                    return undefined;
                if (rawResponse)
                    return response;
                if (noResponse) {
                    if (returnHeaders) {
                        return response.headers;
                    }
                    return {};
                }
                const json = yield response.json();
                log(`${message} Response ${JSON.stringify(json)}`);
                return json;
            }
            catch (err) {
                log(err);
                throw new Error(`Network error occured ${err.message}`);
            }
        });
    }
    isNodeOrCliCall() {
        return this._sesionCookie && this._xsrfToken;
    }
    /**
     * * Returns true; MindSphere Gateway is taking care of this
     *
     * @returns {Promise<boolean>}
     *
     * @memberOf BrowserAuth
     */
    RenewToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return true; // the mindsphere gateway is doing this for us
        });
    }
    /**
     * * Returns ""; MindSphere Gateway is taking care of this
     *
     * @returns {Promise<string>}
     *
     * @memberOf BrowserAuth
     */
    GetToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return ""; // the mindsphere gateway is doing this for us
        });
    }
    /**
     * * Returns ""; MindSphere Gateway is taking care of this
     *
     * @returns {string}
     *
     * @memberOf BrowserAuth
     */
    GetGateway() {
        return this._gateway; // the mindsphere gateway is doing this for us
    }
    /**
     *
     * * Returns ""; MindSphere Gateway is taking care of this
     *
     * @returns {string}
     *
     * @memberOf BrowserAuth
     */
    GetTenant() {
        return ""; // the mindsphere gateway is doing this for us
    }
    getCookieValue(a) {
        if (!document) {
            return undefined;
        }
        const b = document.cookie.match("(^|;)\\s*" + a + "\\s*=\\s*([^;]+)");
        return b ? b.pop() : "";
    }
}
exports.FrontendAuth = FrontendAuth;
//# sourceMappingURL=frontend-auth.js.map