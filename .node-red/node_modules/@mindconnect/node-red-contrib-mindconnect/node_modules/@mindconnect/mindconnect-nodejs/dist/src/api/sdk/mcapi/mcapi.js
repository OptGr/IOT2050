"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MindConnectApiClient = void 0;
const utils_1 = require("../../utils");
const asset_models_1 = require("../asset/asset-models");
const sdk_client_1 = require("../common/sdk-client");
/**
 * MindConnect API Client
 *
 * @export
 * @class MindConnectApiClient
 * @extends {SdkClient}
 */
class MindConnectApiClient extends sdk_client_1.SdkClient {
    constructor() {
        super(...arguments);
        this._baseUrl = "/api/mindconnect/v3";
    }
    /**
     * * diagnostic
     *
     * * Register agent for diagnostic activation
     *
     * @param {string} agentId
     * @returns {Promise<MindConnectApiModels.DiagnosticActivation>}
     *
     * @memberOf MindConnectApiClient
     */
    PostDiagnosticActivation(agentId) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { agentId: agentId };
            return (yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/diagnosticActivations`,
                body: body,
                message: "PostDiagnosticActivation",
            }));
        });
    }
    /**
     * * diagnostic
     *
     * Get the list of diagnostic activations
     *
     * @param {{
     *         size?: number;
     *         page?: number;
     *         sort?: string;
     *     }} [optional]
     * @returns {Promise<MindConnectApiModels.PagedDiagnosticActivation>}
     *
     * @memberOf MindConnectApiClient
     */
    GetDiagnosticActivations(optional) {
        return __awaiter(this, void 0, void 0, function* () {
            const qs = (0, utils_1.toQueryString)(optional);
            return (yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/diagnosticActivations?${qs}`,
                message: "GetDiagnosticActivations",
            }));
        });
    }
    /**
     *
     * *diagnostic
     *
     * Put diagnostic api client
     *
     * @param {string} id
     * @param {MindConnectApiModels.DiagnosticActivationStatus} diagnosticStatus
     * @returns {Promise<MindConnectApiModels.DiagnosticActivation>}
     *
     * @memberOf MindConnectApiClient
     */
    PutDiagnosticActivation(id, diagnosticStatus) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = diagnosticStatus;
            return (yield this.HttpAction({
                verb: "PUT",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/diagnosticActivations/${id}`,
                body: body,
                message: "PutDiagnosticActivation",
            }));
        });
    }
    /**
     * * diagnostic
     *
     * Get current diagnostic activation
     *
     * @param {string} id
     * @returns {Promise<MindConnectApiModels.DiagnosticActivation>}
     *
     * @memberOf MindConnectApiClient
     */
    GetDiagnosticActivation(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/diagnosticActivations/${id}`,
                message: "GetDiagnosticActivation",
            }));
        });
    }
    /**
     * *diagnostic
     *
     * Delete diagnostic activation.
     *
     * @param {string} id
     * @returns
     *
     * @memberOf MindConnectApiClient
     */
    DeleteDiagnosticActivation(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.HttpAction({
                verb: "DELETE",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/diagnosticActivations/${id}`,
                message: "DeleteDiagnosticActivation",
                noResponse: true,
            });
        });
    }
    /**
     * *diagnostic
     *
     * Get messages
     *
     * @param {string} id
     * @param {{ filter?: string; size?: number; page?: number; sort?: string }} [optional]
     * @returns {Promise<MindConnectApiModels.PagedDiagnosticInformationMessages>}
     *
     * @memberOf MindConnectApiClient
     */
    GetDiagnosticActivationMessages(id, optional) {
        return __awaiter(this, void 0, void 0, function* () {
            const qs = (0, utils_1.toQueryString)(optional);
            return (yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/diagnosticActivations/${id}/messages?${qs}`,
                message: "GetDiagnosticActivationMessages",
            }));
        });
    }
    /**
     * * diagnostic
     *
     * @deprecated please use GetDiagnosticActivationMessages
     *
     * Get list of diagnostic informations
     *
     * @param {{
     *         filter?: string;
     *         size?: number;
     *         page?: number;
     *         sort?: string;
     *     }} [optional]
     * @returns {Promise<MindConnectApiModels.PagedDiagnosticInformationMessages>}
     *
     * @memberOf MindConnectApiClient
     */
    GetDiagnosticInformation(optional) {
        return __awaiter(this, void 0, void 0, function* () {
            const qs = (0, utils_1.toQueryString)(optional);
            return (yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/diagnosticInformation?${qs}`,
                message: "GetDiagnosticInformation",
            }));
        });
    }
    /**
     *
     * * diagnostic
     *
     * Deletes all diagnostic activations
     *
     *
     * @memberOf MindConnectApiClient
     */
    DeleteAllDiagnosticActivations() {
        return __awaiter(this, void 0, void 0, function* () {
            const activations = yield this.GetDiagnosticActivations();
            for (const activation of activations.content) {
                if (activation.id)
                    yield this.DeleteDiagnosticActivation(activation.id);
            }
        });
    }
    /**
     * * diagnostic
     *
     * Get all diagnostic information paged (for the CLI)
     *
     * @param {string} agentId
     * @param {(x: MindConnectApiModels.DiagnosticInformation[], ...args: any[]) => any} [callback]
     * @param {*} [callbackOptions]
     * @param {boolean} [skipToLast=true]
     * @returns
     *
     * @memberOf MindConnectApiClient
     */
    GetAllDiagnosticInformation(agentId, callback, callbackOptions, skipToLast = true) {
        return __awaiter(this, void 0, void 0, function* () {
            let pagedInformation;
            let page = 0;
            do {
                pagedInformation = yield this.GetDiagnosticActivationMessages(agentId, { page: page++ });
                if (skipToLast) {
                    page = pagedInformation.totalPages - 2;
                    if (page < 0)
                        page = 0;
                    skipToLast = false;
                    if (!pagedInformation.last) {
                        continue;
                    }
                }
                if (callback) {
                    callback(pagedInformation.content, callbackOptions);
                }
            } while (!pagedInformation.last);
            return pagedInformation;
        });
    }
    /**
     * * mappings
     *
     * Create single mapping
     *
     * @param {MindConnectApiModels.Mapping} mapping
     * @returns
     *
     * @memberOf MindConnectApiClient
     */
    PostDataPointMapping(mapping, optional) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = mapping;
            const parameters = optional || {};
            const { noAgentValidation } = parameters;
            return yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/dataPointMappings?${(0, utils_1.toQueryString)({ noAgentValidation })}`,
                body: body,
                message: "PostDataPointMapping",
                noResponse: true,
                ignoreCodes: optional === null || optional === void 0 ? void 0 : optional.ignoreCodes,
            });
        });
    }
    /**
     *
     * * mappings
     *
     * Get mappings
     *
     * @param {{
     *         filter?: string;
     *         size?: number;
     *         page?: number;
     *         sort?: string;
     *     }} [optional]
     * @returns {Promise<MindConnectApiModels.PagedMapping>}
     *
     * @memberOf MindConnectApiClient
     */
    GetDataPointMappings(optional) {
        return __awaiter(this, void 0, void 0, function* () {
            const qs = (0, utils_1.toQueryString)(optional);
            return (yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/dataPointMappings?${qs}`,
                message: "GetDataPointMappings",
            }));
        });
    }
    /**
     * * mappings
     *
     * Get a mapping by id
     *
     * @param {string} id
     * @returns {Promise<MindConnectApiModels.Mapping>}
     *
     * @memberOf MindConnectApiClient
     */
    GetDataPointMapping(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/dataPointMappings/${id}`,
                message: "GetDataPointMapping",
            }));
        });
    }
    /**
     *
     * Delete a mapping
     *
     * @param {string} id
     * @returns
     *
     * @memberOf MindConnectApiClient
     */
    DeleteDataMapping(id, optional) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.HttpAction({
                verb: "DELETE",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/dataPointMappings/${id}`,
                message: "DeleteDataMapping",
                noResponse: true,
                ignoreCodes: optional === null || optional === void 0 ? void 0 : optional.ignoreCodes,
            });
        });
    }
    /**
     * Generates a Data Source Configuration for specified Asset Type
     *
     * you still have to generate the mappings (or use ConfigureAgentForAssetId method)
     *
     *
     * @param {AssetManagementModels.AssetTypeResource} assetType
     * @param {("NUMERICAL" | "DESCRIPTIVE")} [mode="DESCRIPTIVE"]
     * * NUMERICAL MODE will use names like CF0001 for configurationId , DS0001,DS0002,DS0003... for data source ids and DP0001, DP0002... for dataPointIds
     * * DESCRIPTIVE MODE will use names like CF-assetName for configurationId , DS-aspectName... for data source ids and DP-variableName for data PointIds (default)
     * @returns {Promise<DataSourceConfiguration>}
     *
     * @memberOf MindconnectApiClient
     */
    GenerateDataSourceConfiguration(assetType, mode = "DESCRIPTIVE") {
        var _a;
        let dataSourceConfiguration = {
            configurationId: mode === "NUMERICAL" ? "CF0001" : `CF-${assetType.id.toString().substr(0, 30)}`,
            dataSources: [],
        };
        const dynamicAspects = ((_a = assetType.aspects) === null || _a === void 0 ? void 0 : _a.filter((x) => x.aspectType.category === asset_models_1.AssetManagementModels.AspectType.CategoryEnum.Dynamic)) || [];
        let ds = 0, dp = 0;
        dynamicAspects.forEach((aspect) => {
            const aspectType = aspect.aspectType;
            const dataSource = {
                name: mode === "NUMERICAL"
                    ? `DS${(++ds).toString().padStart(5, "0")}`
                    : `DS-${aspect.name.substr(0, 61)}`,
                dataPoints: [],
                customData: {
                    aspect: aspect.name,
                },
            };
            aspectType.variables.forEach((variable) => {
                dataSource.dataPoints.push({
                    id: mode === "NUMERICAL"
                        ? `DP${(++dp).toString().padStart(5, "0")}`
                        : `DP-${variable.name.substr(0, 33)}`,
                    name: variable.name.substr(0, 64),
                    type: variable.dataType,
                    unit: variable.unit,
                    customData: {
                        variable: `${variable.name}`,
                    },
                });
            });
            dataSourceConfiguration.dataSources.push(dataSource);
        });
        dataSourceConfiguration =
            mode === "NUMERICAL" ? dataSourceConfiguration : this.CreateUniqueDataPoints(dataSourceConfiguration);
        return dataSourceConfiguration;
    }
    CreateUniqueDataPoints(configuration) {
        // check if dataSourceNames are unique
        const datasources = configuration.dataSources.map((x) => x.name);
        const duplicates = this.getDuplicates(datasources);
        duplicates.forEach((duplicate) => {
            let ds = 0;
            configuration.dataSources
                .filter((x) => x.name === duplicate)
                .forEach((d) => {
                d.name = `${d.name.substr(0, 58)}${(++ds).toString().padStart(5, "0")}`;
            });
        });
        const dataPointIds = [];
        configuration.dataSources.forEach((ds) => {
            const ids = ds.dataPoints.map((x) => x.id);
            dataPointIds.push(...ids);
        });
        const dataPointDuplicates = this.getDuplicates(dataPointIds);
        dataPointDuplicates.forEach((duplicate) => {
            let dp = 0;
            configuration.dataSources.forEach((ds) => {
                const dataPoints = ds.dataPoints.filter((x) => x.id === duplicate);
                dataPoints.forEach((p) => {
                    p.id = `${p.id.substr(0, 28)}${(++dp).toString().padStart(5, "0")}`;
                });
            });
        });
        return configuration;
    }
    getDuplicates(x) {
        return [...new Set(x.filter((e, i, a) => a.indexOf(e) !== i))];
    }
    /**
     *  * Generate automatically the mappings for the specified target assetid
     *
     * !Important! this only works if you have created the data source coniguration automatically
     *
     * @param {DataSourceConfiguration} dataSourceConfiguration
     * @param {string} agentId
     * @param {string} targetAssetId
     * @returns {Mapping[]}
     *
     * @memberOf MindConnectApiClient
     */
    GenerateMappings(dataSourceConfiguration, agentId, targetAssetId) {
        const mappings = [];
        !dataSourceConfiguration &&
            (0, utils_1.throwError)("no data source configuration! (have you forgotten to create / generate the data source configuration first?");
        for (const dataSource of dataSourceConfiguration.dataSources) {
            (!dataSource.customData || !dataSource.customData.aspect) &&
                (0, utils_1.throwError)("GenerateMappings works only on configurations created with GenerateDataSourceConfiguration method!");
            for (const datapoint of dataSource.dataPoints) {
                (!datapoint.customData || !datapoint.customData.variable) &&
                    (0, utils_1.throwError)("GenerateMappings works only on configurations created with GenerateDataSourceConfiguration method!");
                mappings.push({
                    agentId: agentId,
                    dataPointId: datapoint.id,
                    entityId: targetAssetId,
                    propertyName: datapoint.customData.variable,
                    propertySetName: dataSource.customData.aspect,
                    keepMapping: true,
                });
            }
        }
        return mappings;
    }
    /**
     *
     * Ingest data to mindsphere
     * ! this is not public in all mindsphere regions yet.
     *
     * @param {string} senderId
     * @param {MindConnectApiModels.IngestionTimeseries} message
     * @returns {Promise<Response>}
     *
     * @memberOf MindConnectApiClient
     */
    Ingest(senderId, message) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                body: message,
                baseUrl: `/api/mindconnect/v3/ingest?${(0, utils_1.toQueryString)({ senderId: senderId })}`,
                rawResponse: true,
            }));
        });
    }
}
exports.MindConnectApiClient = MindConnectApiClient;
//# sourceMappingURL=mcapi.js.map