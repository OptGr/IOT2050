"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnomalyDetectionClient = void 0;
const utils_1 = require("../../utils");
const sdk_client_1 = require("../common/sdk-client");
const anomaly_detection_models_1 = require("./anomaly-detection-models");
/**
 * Service for configuring, reading and managing assets, asset ~ and aspect types.
 *
 * @export
 * @class AssetManagementClient
 * @extends {SdkClient}
 */
class AnomalyDetectionClient extends sdk_client_1.SdkClient {
    constructor() {
        super(...arguments);
        this._baseUrl = "/api/anomalydetection/v3";
    }
    /**
     * Creates new model based on given timeseries data. Analytic Model Management service is used to store created model.
     * @summary Train model
     * @param {Array<Timeseries>} ioTTimeSeriesItems An array containing the time series items. Data to train a model. Data must contain 10 variables at max. Each timeseries item must have equal number of variables.
     * @param {number} epsilon Threshold for the distance to check if point belongs to cluster.
     * @param {number} minPointsPerCluster Minimum cluster size. Positive. Minimum is 2.
     * @param {'EUCLIDEAN' | 'MANHATTAN' | 'CHEBYSHEV'} [distanceMeasureAlgorithm] Name of the distance measure algorithm.
     * @param {string} [name] Human-friendly name of the model. If a name is provided, it must not be an empty string. Maximum length is 255 characters. Only ASCII characters are allowed. Example &#39;Test Model
     * @returns {Array<AnomalyDetectionModels.Timeseries>}
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    PostModel(ioTTimeSeriesItems, epsilon, minPointsPerCluster, distanceMeasureAlgorithm, name) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'ioTTimeSeriesItems' is not null or undefined
            if (ioTTimeSeriesItems === null || ioTTimeSeriesItems === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("ioTTimeSeriesItems", "Required parameter ioTTimeSeriesItems was null or undefined when calling modelsPost.");
            }
            // verify required parameter 'epsilon' is not null or undefined
            if (epsilon === null || epsilon === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("epsilon", "Required parameter epsilon was null or undefined when calling modelsPost.");
            }
            // verify required parameter 'minPointsPerCluster' is not null or undefined
            if (minPointsPerCluster === null || minPointsPerCluster === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("minPointsPerCluster", "Required parameter minPointsPerCluster was null or undefined when calling modelsPost.");
            }
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/models?${(0, utils_1.toQueryString)({
                    epsilon,
                    minPointsPerCluster,
                    distanceMeasureAlgorithm,
                    name,
                })}`,
                body: ioTTimeSeriesItems || {},
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * Performs anomaly detection for given timeseries data against specified model.
     * @summary Anomaly detection
     * @param {Array<AnomalyDetectionModels.Timeseries>} ioTTimeSeriesItems An array containing the time series items. Data to performs detection on. Data must contain 10 variables at max. Each timeseries item must have equal number of variables. Variables must be the same as the ones used to train the model (the same number of variables and the same names).
     * @param {string} modelID ID of the model to use.
     * @returns {Promise<Array<AnomalyDetectionModels.Anomaly>>}
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    DetectAnomalies(ioTTimeSeriesItems, modelID) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'ioTTimeSeriesItems' is not null or undefined
            if (ioTTimeSeriesItems === null || ioTTimeSeriesItems === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("ioTTimeSeriesItems", "Required parameter ioTTimeSeriesItems was null or undefined when calling detectanomaliesPost.");
            }
            // verify required parameter 'modelID' is not null or undefined
            if (modelID === null || modelID === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("modelID", "Required parameter modelID was null or undefined when calling detectanomaliesPost.");
            }
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectanomalies?${(0, utils_1.toQueryString)({ modelID })}`,
                body: ioTTimeSeriesItems || {},
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * Creates new model based on given asset details. Analytic Model Management service is used to store created model.
     * @summary Train model in direct integration with IoT time series
     * @param {number} epsilon Threshold for the distance to check if point belongs to cluster.
     * @param {number} minPointsPerCluster Minimum cluster size. Positive. Minimum is 2.
     * @param {string} assetId unique identifier of the asset (entity)
     * @param {string} aspectName Name of the aspect (property set).
     * @param {Date} from Beginning of the time range to be retrieved (exclusive).
     * @param {Date} to End of the time range to be retrieved (exclusive).
     * @param {'EUCLIDEAN' | 'MANHATTAN' | 'CHEBYSHEV'} [distanceMeasureAlgorithm] Name of the distance measure algorithm.
     * @param {string} [name] Human-friendly name of the model. If a name is provided, it must not be an empty string. Maximum length is 255 characters. Only ASCII characters are allowed. Example &#39;Test Model
     * @returns {Promise<AnomalyDetectionModels.Model>}
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    PostModelDirect(epsilon, minPointsPerCluster, assetId, aspectName, from, to, distanceMeasureAlgorithm, name) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'epsilon' is not null or undefined
            if (epsilon === null || epsilon === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("epsilon", "Required parameter epsilon was null or undefined when calling modelsDirectPost.");
            }
            // verify required parameter 'minPointsPerCluster' is not null or undefined
            if (minPointsPerCluster === null || minPointsPerCluster === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("minPointsPerCluster", "Required parameter minPointsPerCluster was null or undefined when calling modelsDirectPost.");
            }
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("assetId", "Required parameter assetId was null or undefined when calling modelsDirectPost.");
            }
            // verify required parameter 'aspectName' is not null or undefined
            if (aspectName === null || aspectName === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("aspectName", "Required parameter aspectName was null or undefined when calling modelsDirectPost.");
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("from", "Required parameter from was null or undefined when calling modelsDirectPost.");
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("to", "Required parameter to was null or undefined when calling modelsDirectPost.");
            }
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/modelsDirect?${(0, utils_1.toQueryString)({
                    epsilon,
                    minPointsPerCluster,
                    assetId,
                    aspectName,
                    from,
                    to,
                    distanceMeasureAlgorithm,
                    name,
                })}`,
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * Performs anomaly detection for given asset details against specified model.
     * @summary Anomaly detection in direct integration with IoT time series
     * @param {string} modelID ID of the model to use.
     * @param {string} assetId unique identifier of the asset (entity)
     * @param {string} aspectName Name of the aspect (property set).
     * @param {Date} from Beginning of the time range to be retrieved (exclusive).
     * @param {Date} to End of the time range to be retrieved (exclusive).
     * @returns {Promise<Array<AnomalyDetectionModels.Anomaly>>}
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    DetectAnomaliesDirect(modelID, assetId, aspectName, from, to) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'modelID' is not null or undefined
            if (modelID === null || modelID === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("modelID", "Required parameter modelID was null or undefined when calling detectanomaliesDirectPost.");
            }
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("assetId", "Required parameter assetId was null or undefined when calling detectanomaliesDirectPost.");
            }
            // verify required parameter 'aspectName' is not null or undefined
            if (aspectName === null || aspectName === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("aspectName", "Required parameter aspectName was null or undefined when calling detectanomaliesDirectPost.");
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("from", "Required parameter from was null or undefined when calling detectanomaliesDirectPost.");
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("to", "Required parameter to was null or undefined when calling detectanomaliesDirectPost.");
            }
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectanomaliesDirect?${(0, utils_1.toQueryString)({
                    modelID,
                    assetId,
                    aspectName,
                    from,
                    to,
                })}`,
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * Cancels specified job.
     * @summary Cancel jod.
     * @param {string} id ID of the job to get status for.
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    CancelDetectAnomaliesJob(id) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("id", "Required parameter id was null or undefined when calling detectAnomaliesJobsIdCancelPost.");
            }
            yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectAnomaliesJobs/${id}/cancel`,
                additionalHeaders: { "Content-Type": "application/json" },
                noResponse: true,
            });
        });
    }
    /**
     * Returns current status for specified jod.
     * @summary Get job status.
     * @param {string} id ID of the job to get status for.
     * @returns {Promise<AnomalyDetectionModels.ReasoningJobInfo>}
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    GetDetectAnomaliesJob(id) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("id", "Required parameter id was null or undefined when calling detectAnomaliesJobsIdGet.");
            }
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectAnomaliesJobs/${id}`,
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * Performs long running reasoning (anomaly detection) for given timeseries data.
     * @summary Anomaly Detection batch reasoning
     * @param {AnomalyDetectionModels.SubmitReasoningRequest} [submitReasoningRequest] Request data to launch reasoning job.
     * @returns {Promise<AnomalyDetectionModels.ReasoningJobInfo>}
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    PostDetectAnomaliesJob(submitReasoningRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/detectAnomaliesJobs`,
                body: submitReasoningRequest || {},
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * Performs long running model training for given timeseries data. The number of timeseries items to process is limited by 1000000, this parameter can be changed in the future without notice.
     * @summary Anomaly Detection batch model training
     * @param {AnomalyDetectionModels.SubmitTrainingRequest} [submitTrainingRequest] Request data to launch training job.
     * @returns {Promise<AnomalyDetectionModels.TrainingJobInfo>}
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    PostTrainModelJob(submitTrainingRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/trainModelJobs`,
                body: submitTrainingRequest || {},
                additionalHeaders: { "Content-Type": "application/json" },
            });
            return result;
        });
    }
    /**
     * Returns current status for specified jod.
     * @summary Get job status.
     * @param {string} id ID of the job to get status for.
     * @returns {Promise<AnomalyDetectionModels.TrainingJobInfo>}
     * @throws {AnomalyDetectionModels.RequiredError}
     * @memberof AnomalyDetectionClient
     */
    GetTrainModelJob(id) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("id", "Required parameter id was null or undefined when calling trainModelJobsIdGet.");
            }
            const result = yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/trainModelJobs/${id}`,
                additionalHeaders: { "Content-Type": "application/json" },
                noResponse: true,
            });
            return result;
        });
    }
    /**
     * Cancels specified job.
     * @summary Cancel job.
     * @param {string} id ID of the job to get status for.
     * @throws {RequiredError}
     * @memberof AnomalyDetectionClient
     */
    CancelTrainModelJob(id) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new anomaly_detection_models_1.AnomalyDetectionModels.RequiredError("id", "Required parameter id was null or undefined when calling trainModelJobsIdCancelPost.");
            }
            yield this.HttpAction({
                verb: "POST",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/trainModelJobs/${id}/cancel`,
                additionalHeaders: { "Content-Type": "application/json" },
                noResponse: true,
            });
        });
    }
}
exports.AnomalyDetectionClient = AnomalyDetectionClient;
//# sourceMappingURL=anomaly-detection.js.map