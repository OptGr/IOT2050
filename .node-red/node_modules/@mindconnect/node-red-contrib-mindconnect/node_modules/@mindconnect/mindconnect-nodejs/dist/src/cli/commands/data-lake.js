"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.listPermissions = void 0;
const console_1 = require("console");
const path = require("path");
const sdk_1 = require("../../api/sdk");
const utils_1 = require("../../api/utils");
const command_utils_1 = require("./command-utils");
const ora = require("ora");
let color = (0, command_utils_1.getColor)("magenta");
exports.default = (program) => {
    program
        .command("data-lake")
        .alias("dlk")
        .option("-m, --mode [...]", "mode: list | read | write | delete | readtoken | writetoken | uploadurl | downloadurl | upload | meta | subscriptions | subscribe | unsubscribe ", "list")
        .option("-f, --file <file>", "file to upload")
        .option("-l, --shell [bash|ps|cmd]", "output format for STS token [bash | ps | cmd]", "bash")
        .option("-p, --path <path>", "path for read/write token or uploadUrl, downloadUrl, subscribe or unsubscribe comamand")
        .option("-t, --destination <destination>", "destination for subscribe comamand")
        .option("-i, --permissionid <permissionid>", "permission id for delete operation")
        .option("-s, --subtenantid <subtenantid>", "subtenant id")
        .option("-b, --subscriptionid <subscriptionid>", "subscription id")
        .option("-d, --duration <duration>", "duration in seconds", "3600")
        .option("-k, --passkey <passkey>", "passkey")
        .option("-y, --retry <number>", "retry attempts before giving up", "3")
        .option("-v, --verbose", "verbose output")
        .description(color(`manage data lake, data lake access permissions and STS tokens *`))
        .action((options) => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                checkRequiredParameters(options);
                const sdk = (0, command_utils_1.getSdk)(options);
                color = (0, command_utils_1.adjustColor)(color, options);
                (0, command_utils_1.homeDirLog)(options.verbose, color);
                (0, command_utils_1.proxyLog)(options.verbose, color);
                switch (options.mode) {
                    case "list":
                        yield listPermissions(options, sdk);
                        break;
                    case "subscriptions":
                        yield subscriptions(sdk, options);
                        break;
                    case "subscribe":
                        yield subscribe(sdk, options);
                        break;
                    case "unsubscribe":
                        yield unsubscribe(sdk, options);
                        break;
                    case "meta":
                        yield getMetadata(sdk, options);
                        break;
                    case "write":
                        yield allowWrite(sdk, options);
                        break;
                    case "delete":
                        yield deletePermission(sdk, options);
                        break;
                    case "readtoken":
                    case "writetoken":
                        yield generateToken(sdk, options);
                        break;
                    case "uploadurl":
                        yield uploadUrl(sdk, options);
                        break;
                    case "upload":
                        yield uploadFile(sdk, options);
                        break;
                    case "downloadurl":
                        yield downloadUrl(sdk, options);
                        break;
                    default:
                        throw Error(`no such option: ${options.mode}`);
                }
            }
            catch (err) {
                (0, command_utils_1.errorLog)(err, options.verbose);
            }
        }))();
    })
        .on("--help", () => {
        (0, console_1.log)("\n  Examples:\n");
        (0, console_1.log)(`    mc data-lake --mode list \t\t\tlists all configured permissions for data lake`);
        (0, console_1.log)(`    mc data-lake --mode write \t\t\tallow writing to the data lake`);
        (0, console_1.log)(`    mc data-lake --mode write --path data/ \tallow writing to the data lake from data/ folder`);
        (0, console_1.log)(`    mc data-lake --mode meta --path data/ \tget metadata for path`);
        (0, console_1.log)(`    mc data-lake --mode readtoken \t\tcreate AWS STS Token with read rights`);
        (0, console_1.log)(`    mc data-lake --mode writetoken \t\tcreate AWS STS Token with write rights from data lake root`);
        (0, console_1.log)(`    mc data-lake --mode writetoken --path data/ create AWS STS Token with write rights from data/ folder`);
        (0, console_1.log)(`    mc data-lake --mode delete --permissionid  <permissionid>\t\t\t delete writing permission with selected permissionid`);
        (0, console_1.log)(`    mc data-lake --mode upload --file CHANGELOG.md --path uploads/CHANGELOG.md \t upload file to data lake`);
        (0, console_1.log)(`    mc data-lake --mode downloadurl --path uploads/CHANGELOG.md \t\t generate download url for the path`);
        (0, console_1.log)(`    mc data-lake --mode subscriptions \t\t\t\t\t\t list all data lake event subscriptions`);
        (0, console_1.log)(`    mc data-lake --mode subscribe --path <datalakepath> --destination aws-sns://<aws sns topic> \t subscribe an AWS SNS topic to folder changes`);
        (0, console_1.log)(`    mc data-lake --mode unsubscribe --subscriptionid <id>  \t\t\t delete event subscription`);
        (0, console_1.log)("\n  Additional Information:\n");
        (0, console_1.log)(`    Purchasing Data Lake: ${color("https://www.dex.siemens.com/mindsphere/applications/integrated-data-lake")}`);
        (0, console_1.log)(`    Data Lake APIs: ${color("https://developer.mindsphere.io/apis/iot-integrated-data-lake/api-integrated-data-lake-overview.html")}`);
        (0, command_utils_1.serviceCredentialLog)();
    });
};
function downloadUrl(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = yield sdk.GetDataLakeClient().GenerateDownloadObjectUrls({
            paths: [{ path: `${options.path}` }],
            subtenantId: options.subtenantid,
        });
        (0, command_utils_1.verboseLog)(JSON.stringify(url, null, 2), options.verbose);
        console.log(`\nDownload URL for ${color(url.objectUrls[0].path)}`);
        console.log(`\nClick on the URL below to download the file:\n`);
        console.log(color(url.objectUrls[0].signedUrl));
    });
}
function uploadFile(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const fullPath = path.resolve(options.file);
        const spinner = ora(`Uploading ${color(fullPath)} to data Lake`);
        !options.verbose && spinner.start();
        (0, command_utils_1.verboseLog)(`Creating Data Lake upload URL`, options.verbose, spinner);
        const url = yield sdk.GetDataLakeClient().GenerateUploadObjectUrls({
            paths: [{ path: `${options.path}` }],
            subtenantId: options.subtenantid,
        });
        (0, command_utils_1.verboseLog)(`Uploading file ${color(fullPath)} as ${color(url.objectUrls[0].path)} to data lake`, options.verbose, spinner);
        (0, command_utils_1.verboseLog)(JSON.stringify(url, null, 2), options.verbose);
        const result = yield sdk.GetDataLakeClient().PutFile(fullPath, url.objectUrls[0].signedUrl);
        (0, command_utils_1.verboseLog)(JSON.stringify(result, null, 2), options.verbose);
        spinner.succeed(`Uploaded file ${color(fullPath)} as ${color(url.objectUrls[0].path)} to data lake`);
    });
}
function getMetadata(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const metadata = yield sdk
            .GetDataLakeClient()
            .GetObjectMetaData(`${options.path}`, { subtenantid: options.subtenantid });
        (0, command_utils_1.verboseLog)(JSON.stringify(metadata, null, 2), options.verbose);
        console.log(`path size lastModified, subtenantid tags `);
        console.log(`${color(metadata.path || metadata.location)} ${metadata.size} ${metadata.lastModified} ${metadata.subtenantId || ``} ${JSON.stringify(metadata.tags)} `);
    });
}
function uploadUrl(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = yield sdk.GetDataLakeClient().GenerateUploadObjectUrls({
            paths: [{ path: `${options.path}` }],
            subtenantId: options.subtenantid,
        });
        (0, command_utils_1.verboseLog)(JSON.stringify(url, null, 2), options.verbose);
        console.log(`\nUpload URL for ${color(url.objectUrls[0].path)}`);
        console.log(`\nUpload file to the URL below:\n`);
        console.log(color(url.objectUrls[0].signedUrl));
    });
}
function deletePermission(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        yield sdk.GetDataLakeClient().DeleteAccessTokenPermission(options.permissionid);
        console.log(`Permission with id ${options.permissionid} was deleted`);
    });
}
function allowWrite(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield sdk.GetDataLakeClient().PostAccessTokenPermissions({
            path: `${options.path || "/"}`,
            subtenantId: options.subtenantid,
            permission: sdk_1.DataLakeModels.AccessPermission.WRITE,
        });
        (0, command_utils_1.verboseLog)(result, options.verbose);
        console.log(`${result.id} ${color(result.path)}\t${result.permission}\t${result.created}\t${color(result.subtenantId || "")}`);
        console.log(`Write permission with ${result.id} created.`);
    });
}
function generateToken(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataLake = sdk.GetDataLakeClient();
        const result = yield dataLake.GenerateAccessToken((0, utils_1.removeUndefined)({
            path: options.path || "/",
            permission: options.mode === "readtoken"
                ? sdk_1.DataLakeModels.AccessTokenPermission.READ
                : sdk_1.DataLakeModels.AccessTokenPermission.WRITE,
            subtenantId: options.subtenantid,
            durationSeconds: options.duration ? parseInt(options.duration) : undefined,
        }));
        console.log(`\nCopy the following commands to your ${color(options.shell)} shell to enable s3 authorization:`);
        switch (options.shell) {
            case "bash":
                console.log(`\nexport AWS_ACCESS_KEY_ID="${result.credentials.accessKeyId}"`);
                console.log(`export AWS_SECRET_ACCESS_KEY="${result.credentials.secretAccessKey}"`);
                console.log(`export AWS_SESSION_TOKEN="${result.credentials.sessionToken}"`);
                break;
            case "ps":
                console.log(`\n$Env:AWS_ACCESS_KEY_ID="${result.credentials.accessKeyId}"`);
                console.log(`$Env:AWS_SECRET_ACCESS_KEY="${result.credentials.secretAccessKey}"`);
                console.log(`$Env:AWS_SESSION_TOKEN="${result.credentials.sessionToken}"`);
                break;
            case "cmd":
                console.log(`\nset "AWS_ACCESS_KEY_ID=${result.credentials.accessKeyId}"`);
                console.log(`set "AWS_SECRET_ACCESS_KEY=${result.credentials.secretAccessKey}"`);
                console.log(`set "AWS_SESSION_TOKEN=${result.credentials.sessionToken}"`);
                break;
            default:
                break;
        }
        console.log(`\nExample ${color("aws s3 ls")} command:`);
        console.log(`\n\taws s3 ls s3://${result.storageAccount}/${result.storagePath}`);
        console.log(`\nIntegrated Data Lake S3 bucket:`);
        console.log(color(`\n\ts3://${result.storageAccount}/${result.storagePath}\n`));
    });
}
function subscriptions(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataLake = sdk.GetDataLakeClient();
        let page = 0;
        let subs;
        let subsCount = 0;
        console.log(`subid storageAccount ${color("storagePath")} destination eTag status subTenantId`);
        do {
            subs = (yield (0, utils_1.retry)(options.retry, () => dataLake.GetObjectEventSubscriptions({
                page: page,
                size: 100,
            })));
            subs.page = subs.page || { totalPages: 0 };
            for (const sub of subs.subscriptions || []) {
                subsCount++;
                console.log(`${sub.id} ${sub.storageAccount} ${color(sub.storagePath)} ${sub.destination} ${sub.eTag} ${sub.status} \t${color(sub.subtenantId || "")}`);
                (0, command_utils_1.verboseLog)(JSON.stringify(sub, null, 2), options.verbose);
            }
        } while (page++ < (subs.page.totalPages || 0));
        console.log(`${color(subsCount)} subscriptions listed.\n`);
    });
}
function subscribe(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataLake = sdk.GetDataLakeClient();
        const result = yield dataLake.PostObjectEventSubscriptions({
            destination: options.destination,
            path: options.path,
            subtenantId: options.subtenantid,
        });
        (0, command_utils_1.verboseLog)(result, options.verbose);
        console.log(`Subscription created.`);
    });
}
function unsubscribe(sdk, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataLake = sdk.GetDataLakeClient();
        const sub = yield dataLake.GetObjectEventSubscription(options.subscriptionid);
        yield dataLake.DeleteObjectEventSubscription(options.subscriptionid, {
            ifMatch: parseInt(sub.eTag.toString()),
        });
        console.log(`Subscription with ${color(options.subscriptionid)} deleted.`);
    });
}
function listPermissions(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataLake = sdk.GetDataLakeClient();
        let page = 0;
        let paths;
        let pathCount = 0;
        console.log(`permissionid\t${color("path")}\tmode\tcreated\tsubtentantid`);
        do {
            paths = (yield (0, utils_1.retry)(options.retry, () => dataLake.GetAccessTokenPermissions({
                page: page,
                size: 100,
            })));
            paths.page = paths.page || { totalPages: 0 };
            for (const path of paths.accessTokenPermissions || []) {
                pathCount++;
                console.log(`${path.id} ${color(path.path)}\t${path.permission}\t${path.created}\t${color(path.subtenantId || "")}`);
                (0, command_utils_1.verboseLog)(JSON.stringify(path, null, 2), options.verbose);
            }
        } while (page++ < (paths.page.totalPages || 0));
        console.log(`${color(pathCount)} permissions listed.\n`);
    });
}
exports.listPermissions = listPermissions;
function checkRequiredParameters(options) {
    ["upload", "uploadurl", "downloadurl", "meta", "subscribe"].includes(options.mode) &&
        !options.path &&
        (0, command_utils_1.errorLog)(`You have to specify --path for mc data-lake --mode ${options.mode} command.`, true);
    ["upload", "uploadurl"].includes(options.mode) &&
        !options.file &&
        (0, command_utils_1.errorLog)(`You have to specify --file for mc data-lake --mode ${options.mode} command.`, true);
    options.mode === "delete" &&
        !options.permissionid &&
        (0, command_utils_1.errorLog)("You have to specify the permissionid for delete command.", true);
    options.shell &&
        !["bash", "ps", "cmd"].includes(options.shell) &&
        (0, command_utils_1.errorLog)("The shell can only be bash, ps (Windows PowerShell) or cmd (Windows cmd).", true);
    options.mode === "subscribe" &&
        !options.destination &&
        (0, command_utils_1.errorLog)("You have to specify the destination topic for notification.", true);
    options.mode === "unsubscribe" &&
        !options.subscriptionid &&
        (0, command_utils_1.errorLog)("You have to specify the subscriptionid.", true);
}
//# sourceMappingURL=data-lake.js.map