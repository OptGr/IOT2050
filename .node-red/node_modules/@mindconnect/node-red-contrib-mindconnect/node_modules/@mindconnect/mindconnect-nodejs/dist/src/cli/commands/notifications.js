"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const fs = require("fs");
const path = require("path");
const utils_1 = require("../../api/utils");
const command_utils_1 = require("./command-utils");
const mime = require("mime-types");
let color = (0, command_utils_1.getColor)("magenta");
exports.default = (program) => {
    program
        .command("notifications")
        .alias("nt")
        .option("-m, --mode [template|status|send]", "mode [template|send]", "template")
        .option("-t, --type [email|sms|push]", "type [email|sms|push]", "email")
        .option("-i, --jobid <jobid>", "job id for status command")
        .option("-f, --metadata <metadata>", "metadata file with notification infos")
        .option("-a, --files <files>", "comma separated list of attachement files for email (max 5)")
        .option("-o, --overwrite", "overwrite template files")
        .option("-k, --passkey <passkey>", "passkey")
        .option("-y, --retry <number>", "retry attempts before giving up", "3")
        .option("-v, --verbose", "verbose output")
        .description(color(`send email, sms and push notifications *`))
        .action((options) => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                checkRequiredParameters(options);
                const sdk = (0, command_utils_1.getSdk)(options);
                color = (0, command_utils_1.adjustColor)(color, options, true);
                (0, command_utils_1.homeDirLog)(options.verbose, color);
                (0, command_utils_1.proxyLog)(options.verbose, color);
                switch (options.mode) {
                    case "template":
                        yield createTemplate(options);
                        console.log("Edit the file before submitting it to mindsphere.");
                        break;
                    case "send":
                        yield sendMessage(options, sdk);
                        break;
                    case "status":
                        yield getStatus(options, sdk);
                        break;
                    default:
                        throw Error(`no such option: ${options.mode}`);
                }
            }
            catch (err) {
                (0, command_utils_1.errorLog)(err, options.verbose);
            }
        }))();
    })
        .on("--help", () => printHelp());
};
function printHelp() {
    (0, console_1.log)("\n  Examples:\n");
    (0, console_1.log)(`    mc notifications --mode template --type [mail|sms|push] \t create template file with notification metadata`);
    (0, console_1.log)(`    mc notifications --mode send --metadata <[mail|sms|push].metadata.mdsp.json> --type [mail|sms|push] \n\t\t\t\t\t send notifications (mail, sms, push) to recipients`);
    (0, command_utils_1.serviceCredentialLog)();
}
function createTemplate(options) {
    return __awaiter(this, void 0, void 0, function* () {
        let metadata;
        switch (options.type) {
            case "email":
                metadata = {
                    subject: "[Status] Demo Mail Notificationfrom MindSphere CLI",
                    message: `This is a demo mail notification from MindSphere CLI. See more at https://opensource.mindsphere.io`,
                    fromApplication: "CLI",
                    priority: "Normal",
                    recipients: ["<recipient1>@<email>", "<recipient2>@<email>"],
                };
                break;
            case "sms":
                metadata = {
                    message: `This is a demo sms notification from MindSphere CLI`,
                    fromApplication: "CLI",
                    recipients: ["+411xxxxxxx9", "+911xxxxxxx9"],
                };
                break;
            case "push":
                metadata = {
                    mobileAppId: "<mobileappid>",
                    recipients: {
                        appInstanceIds: ["<appinstanceid>"],
                        userEmailAddresses: ["<user>@<email>"],
                    },
                    message: {
                        title: '{ "en": "Siemens Mindsphere", "de": "Siemens MindSphere"}',
                        text: '{ "en": "Hi there, Welcome to MindSphere!", "de": "Hallo, Willkommen bei MindSphere!"}',
                    },
                };
                break;
            default:
                throw Error(`The type ${options.type} is not supported`);
        }
        const fileName = options.metadata || `${options.type}.metadata.mdsp.json`;
        const filePath = path.resolve(fileName);
        fs.existsSync(filePath) && !options.overwrite && (0, utils_1.throwError)(`the file ${filePath} already exists.`);
        fs.writeFileSync(filePath, JSON.stringify(metadata, null, 2));
        console.log(`The ${options.mode} metadata was written into ${color(fileName)}. Run \n\n\t mc notifications --mode send --metadata ${fileName} --type ${options.type} \n\nto send ${color(options.type)} notifications.`);
    });
}
function sendMessage(options, sdk) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = path.resolve(options.metadata);
        const filecontent = fs.readFileSync(filePath);
        const filedata = JSON.parse(filecontent.toString());
        const notificationClient = sdk.GetNotificationClientV4();
        let result;
        switch (options.type) {
            case "email":
                {
                    const files = options.files ? `${options.files}`.split(",") : [];
                    const attachements = [];
                    files.forEach((file) => {
                        const currentFile = path.resolve(file.trim());
                        const baseName = path.basename(currentFile);
                        const buffer = fs.readFileSync(currentFile);
                        const mimetype = mime.lookup(currentFile);
                        console.log(`Attaching file: ${color(currentFile)} mime type: ${mimetype}`);
                        attachements.push({ buffer: buffer, fileName: baseName, mimeType: mimetype });
                    });
                    result = yield notificationClient.PostMulticastEmailNotificationJob(filedata, attachements);
                }
                break;
            case "sms":
                result = yield notificationClient.PostMulticastSMSNotificationJob(filedata);
                break;
            case "push":
                result = yield notificationClient.PostMulticastPushNotificationJob(filedata);
                break;
            default:
                throw Error(`The type ${options.type} is not supported`);
        }
        (0, command_utils_1.verboseLog)(JSON.stringify(result, null, 2), options.verbose);
        console.log(`the ${color(options.type)} notification job with id ${result.id} was created`);
        console.log(`Run \n\n\t mc notifications --mode status --jobid ${result.id} --type ${options.type} \n\nto check the status of the ${color(options.type)} job.`);
    });
}
function getStatus(options, sdk) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const notificationClient = sdk.GetNotificationClientV4();
        switch (options.type) {
            case "email":
                {
                    const result = yield notificationClient.GetMulticastEmailNotificationJob(options.jobid);
                    (0, command_utils_1.verboseLog)(JSON.stringify(result, null, 2), options.verbose);
                    console.log(`${color(options.type)} job with id ${options.jobid}:`);
                    console.log(`Status: ${color(result.status)}`);
                    console.log(`From Application: ${color(result.fromApplication)}`);
                    console.log(`Malicious attachments: ${color((_a = result.maliciousAttachments) === null || _a === void 0 ? void 0 : _a.length)}`);
                    console.log(`Start time: ${color(result.startTime)}`);
                }
                break;
            case "sms":
                {
                    const result = yield notificationClient.GetMulticastSMSNotificationJob(options.jobid);
                    (0, command_utils_1.verboseLog)(JSON.stringify(result, null, 2), options.verbose);
                    console.log(`${color(options.type)} job with id ${options.jobid}:`);
                    console.log(`Status: ${color(result.status)}`);
                    console.log(`From Application: ${color(result.fromApplication)}`);
                    console.log(`Start time: ${color(result.startTime)}`);
                }
                break;
            case "push":
                {
                    try {
                        const result = yield notificationClient.GetMulticastPushNotificationJob(options.jobid);
                        (0, command_utils_1.verboseLog)(JSON.stringify(result, null, 2), options.verbose);
                        console.log(`${color(options.type)} job with id ${options.jobid}:`);
                        console.log(`Status: ${color(result.status)}`);
                        console.log(`Start time: ${color(result.startTime)}`);
                    }
                    catch (err) {
                        console.log("Error occured. In April 2021 there was no method available to get the status of the MulticastPushNotificationJob");
                        console.log("This was reported to MindSphere dev team and should eventually start working...");
                        throw err;
                    }
                }
                break;
            default:
                throw Error(`The type ${options.type} is not supported`);
        }
    });
}
function checkRequiredParameters(options) {
    options.mode === "status" &&
        !options.jobid &&
        (0, command_utils_1.errorLog)("You have to specify the job id for mc nt --mode status command ", true);
    options.mode === "status" &&
        !options.type &&
        (0, command_utils_1.errorLog)("You have to specify the job id for mc nt --mode status command ", true);
    options.mode === "send" &&
        !options.type &&
        (0, command_utils_1.errorLog)("You have to specify the --type [email|sms|push] option for mc nt --mode send command ", true);
    options.mode === "send" &&
        !options.metadata &&
        (0, command_utils_1.errorLog)("You have to specify the template file (--metadata path) for mc nt --mode send command ", true);
}
//# sourceMappingURL=notifications.js.map