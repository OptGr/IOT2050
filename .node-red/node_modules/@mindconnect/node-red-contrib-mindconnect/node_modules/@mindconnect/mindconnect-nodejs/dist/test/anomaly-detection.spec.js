"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
const debug = require("debug");
require("url-search-params-polyfill");
const sdk_1 = require("../src/api/sdk");
const utils_1 = require("../src/api/utils");
const command_utils_1 = require("../src/cli/commands/command-utils");
const test_agent_setup_utils_1 = require("./test-agent-setup-utils");
const test_utils_1 = require("./test-utils");
const log = debug("mindconnect-setup-test");
chai.should();
const timeOffset = new Date().getTime();
let modelIDTotest = null;
describe("[SDK] AnomalyDetectionClient", () => {
    const auth = (0, utils_1.loadAuth)();
    const sdk = new sdk_1.MindSphereSdk(Object.assign(Object.assign({}, auth), { basicAuth: (0, utils_1.decrypt)(auth, (0, test_utils_1.getPasskeyForUnitTest)()) }));
    const tenant = sdk.GetTenant();
    const anomalyDetectionClient = sdk.GetAnomalyDetectionClient();
    const modelManagement = sdk.GetModelManagementClient();
    let assetId = "";
    let unitTestConfiguration = {};
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        // delete all models that might be generated by us.
        yield deleteModels(modelManagement);
        // Set up the infrastructure
        unitTestConfiguration = yield (0, test_agent_setup_utils_1.unitTestSetup)(sdk, sdk_1.AgentManagementModels.AgentUpdate.SecurityProfileEnum.SHAREDSECRET);
        assetId = `${unitTestConfiguration.targetAsset.assetId}`;
    }));
    after(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, test_agent_setup_utils_1.tearDownAgents)(sdk, unitTestConfiguration);
        yield deleteModels(modelManagement);
    }));
    it("should instantiate", () => {
        const _anomalyDetectionClient = sdk.GetAnomalyDetectionClient();
        log(_anomalyDetectionClient);
        _anomalyDetectionClient.should.exist;
    });
    it("SDK should not be undefined", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
        anomalyDetectionClient.should.not.be.undefined;
    }));
    it("should train a new model. @sanity", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
        anomalyDetectionClient.should.not.be.undefined;
        modelManagement.should.not.be.undefined;
        // get the count of models
        const models = yield modelManagement.GetModels();
        models.should.not.be.undefined;
        models.should.not.be.null;
        models.page.number.should.equal(0);
        models.page.size.should.be.gte(0);
        // generate new Data
        const generatedData = (0, command_utils_1.generateTestData)(100, (x) => {
            return 80 + Math.random() * 20 * Math.sin(x);
        }, "Acceleration", "number");
        // Create a new model
        const model = yield anomalyDetectionClient.PostModel(generatedData, 50, 10, "EUCLIDEAN", `xyz_${tenant}_${timeOffset}_ano_A`);
        model.should.not.be.undefined;
        model.should.not.be.null;
        model.id.should.not.be.undefined;
        model.id.should.not.be.null;
        modelIDTotest = model.id;
        const models_after = yield modelManagement.GetModels();
        models_after.should.not.be.undefined;
        models_after.should.not.be.null;
        models_after.page.number.should.equal(0);
        // (models_after as any).page.size.should.be.gt(model_count);
    }));
    it("should test the model and find no anomalies.", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
        anomalyDetectionClient.should.not.be.undefined;
        // generate new Data
        const generatedData = (0, command_utils_1.generateTestData)(500, (x) => {
            return 80 + Math.random() * 20 * Math.sin(x);
        }, "Acceleration", "number");
        // test the model
        const anomalies = yield anomalyDetectionClient.DetectAnomalies(generatedData, `${modelIDTotest}`);
        anomalies.should.not.be.undefined;
        anomalies.should.not.be.null;
        anomalies.length.should.be.equals(0);
    }));
    it("should test the model and find some anomalies.", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
        anomalyDetectionClient.should.not.be.undefined;
        // generate new Data
        const generatedData = (0, command_utils_1.generateTestData)(90, (x) => {
            return 80 + Math.random() * 20 * Math.sin(x);
        }, "Acceleration", "number");
        const generatedData2 = (0, command_utils_1.generateTestData)(10, (x) => {
            return 5 + Math.random() * 10 * Math.sin(x);
        }, "Acceleration", "number");
        const allGeneratedData = generatedData.concat(generatedData2);
        // test the model
        const anomalies = yield anomalyDetectionClient.DetectAnomalies(allGeneratedData, `${modelIDTotest}`);
        anomalies.should.not.be.undefined;
        anomalies.should.not.be.null;
        anomalies.length.should.be.gte(0);
    }));
    it("should train a new model from already existing asset data", () => __awaiter(void 0, void 0, void 0, function* () {
        sdk.should.not.be.undefined;
        anomalyDetectionClient.should.not.be.undefined;
        modelManagement.should.not.be.undefined;
        assetId.should.not.be.undefined;
        assetId.should.not.be.equal("");
        (0, utils_1.checkAssetId)(assetId);
        // get the count of models
        const models = yield modelManagement.GetModels();
        models.should.not.be.undefined;
        models.should.not.be.null;
        models.page.number.should.equal(0);
        models.page.size.should.be.gte(0);
        //
        const now = new Date();
        const lastMonth = new Date();
        lastMonth.setDate(lastMonth.getDate() - 7);
        const fromLastMonth = new Date(lastMonth.getUTCFullYear(), lastMonth.getUTCMonth(), lastMonth.getUTCDate());
        const toNow = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
        // Create a new model
        const model = yield anomalyDetectionClient.PostModelDirect(5.0, 2, assetId, `VibrationData`, fromLastMonth, toNow, "EUCLIDEAN", `xyz_${tenant}_${timeOffset}_ano_B`);
        model.should.not.be.undefined;
        model.should.not.be.null;
        model.id.should.not.be.undefined;
        model.id.should.not.be.null;
        const models_after = yield modelManagement.GetModels();
        models_after.should.not.be.undefined;
        models_after.should.not.be.null;
        models_after.page.number.should.equal(0);
    }));
    function deleteModels(mm) {
        var e_1, _a;
        var _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, test_utils_1.sleep)(2000);
            const models = yield mm.GetModels({
                filter: JSON.stringify({
                    author: "analytics-amm-client",
                }),
            });
            yield (0, test_utils_1.sleep)(3000);
            try {
                for (var _f = __asyncValues(models.models || []), _g; _g = yield _f.next(), !_g.done;) {
                    const x = _g.value;
                    if ((_e = (_d = (_c = (_b = x === null || x === void 0 ? void 0 : x.lastVersion) === null || _b === void 0 ? void 0 : _b.io) === null || _c === void 0 ? void 0 : _c.optionalParameters) === null || _d === void 0 ? void 0 : _d.modelName) === null || _e === void 0 ? void 0 : _e.startsWith("xyz")) {
                        yield mm.DeleteModel(x.id);
                    }
                    yield (0, test_utils_1.sleep)(1000);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) yield _a.call(_f);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
});
//# sourceMappingURL=anomaly-detection.spec.js.map