"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeSeriesClient = void 0;
const utils_1 = require("../../utils");
const sdk_client_1 = require("../common/sdk-client");
/**
 * Store and query time series data with a precision of 1 millisecond.
 *
 * @export
 * @class TimeSeriesClient
 * @extends {SdkClient}
 */
class TimeSeriesClient extends sdk_client_1.SdkClient {
    constructor() {
        super(...arguments);
        this._baseUrl = "/api/iottimeseries/v3";
    }
    /**
     * Read time series data for a single entity and propertyset. Returns data for a specified time range. Returns the latest value if no range is provided.
     *
     * @param {string} entity
     * @param {string} propertysetname
     * @param {{ from?: Date; to?: Date; limit?: number; select?: string; sort?: string }} [optional]
     * @returns {Promise<TimeSeriesModels.Timeseries[]>}
     *
     * @memberOf TimeSeriesClient
     */
    GetTimeSeries(entity, propertysetname, optional) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_1.checkAssetId)(entity);
            const qs = (0, utils_1.toQueryString)(optional);
            return (yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/timeseries/${entity}/${propertysetname}?${qs}`,
                message: "GetTimeSeries",
            }));
        });
    }
    /**
     * Returns the data bulk style.
     *
     * ! This is necessary as bulk data upload has a bug with links and limits in December 2019
     *
     * @param {string} entity
     * @param {string} propertysetname
     * @param {{
     *       from?: Date;
     *       to?: Date;
     *       limit?: number;
     *       select?: string;
     *       sort?: string;
     *     }} [optional]
     * @returns {Promise<TimeSeriesModels.BulkTimeseries>}
     *
     * @memberOf TimeSeriesClient
     */
    GetTimeSeriesBulkStyle(entity, propertysetname, optional) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_1.checkAssetId)(entity);
            const qs = (0, utils_1.toQueryString)(optional);
            const url = `${this._baseUrl}/timeseries/${entity}/${propertysetname}?${qs}`;
            return yield this.GetNextRecordsBulkStyle(url);
        });
    }
    GetNextRecordsBulkStyle(url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const response = (yield this.HttpAction({
                verb: "GET",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: url,
                message: "GetTimeSeries",
                rawResponse: true,
            }));
            const nextRecord = (_a = response.headers
                .get("link")) === null || _a === void 0 ? void 0 : _a.replace('; rel="next"', "").replace(/</g, "").replace(/>/g, "").replace(this.GetGateway(), "");
            const values = (yield response.json());
            return {
                records: values,
                nextRecord: nextRecord,
            };
        });
    }
    /**

    /**
     * Write or update time series data for a single entity and propertyset. Existing time series data is overwritten. Data for all properties within a propertyset needs to be provided together.
     *
     * @param {string} entity
     * @param {string} propertysetname
     * @param {TimeSeriesModels.Timeseries[]} timeseries
     * @returns
     *
     * @memberOf TimeSeriesClient
     */
    PutTimeSeries(entity, propertysetname, timeseries) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_1.checkAssetId)(entity);
            return yield this.HttpAction({
                verb: "PUT",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/timeseries/${entity}/${propertysetname}`,
                body: timeseries,
                message: "PutTimeSeries",
                noResponse: true,
            });
        });
    }
    /**
     * Delete time series data for a single entity and propertyset within a given time range.
     * Data for all properties within a propertyset is deleted.
     *
     * @param {string} entity
     * @param {string} propertysetname
     * @param {Date} from
     * @param {Date} to
     * @returns
     *
     * @memberOf TimeSeriesClient
     */
    DeleteTimeSeries(entity, propertysetname, from, to) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_1.checkAssetId)(entity);
            const qs = (0, utils_1.toQueryString)({ from: from, to: to });
            return yield this.HttpAction({
                verb: "DELETE",
                gateway: this.GetGateway(),
                authorization: yield this.GetToken(),
                baseUrl: `${this._baseUrl}/timeseries/${entity}/${propertysetname}?${qs}`,
                message: "DeleteTimeSeries",
                noResponse: true,
            });
        });
    }
}
exports.TimeSeriesClient = TimeSeriesClient;
//# sourceMappingURL=iot-timeseries.js.map