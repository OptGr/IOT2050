"use strict";
// Copyright Siemens AG, 2019
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
const fs = require("fs");
const mocha_1 = require("mocha");
const path = require("path");
const mcnode = require("../src/mindconnect.js");
const helper = require("node-red-node-test-helper");
helper.init(require.resolve("node-red"));
chai.should();
describe("MindConnect Node-RED node", () => {
    beforeEach((done) => {
        helper.startServer(done);
    });
    afterEach((done) => {
        helper.unload();
        helper.stopServer(done);
    });
    let sharedSecretConfig = {};
    if (fs.existsSync(path.resolve("../agentconfig.json"))) {
        sharedSecretConfig = JSON.parse(fs.readFileSync(path.resolve("../agentconfig.json")).toString());
    }
    const nodeTemplate = {
        type: "mindconnect",
        configtype: "SHARED_SECRET",
        agentconfig: JSON.stringify(sharedSecretConfig),
        privatekey: "",
        model: "",
        validate: true,
        validateevent: true,
        chunk: false,
        disablekeepalive: false,
        retry: "3",
    };
    mocha_1.it("should instantiate @ci", (done) => {
        helper.should.not.be.null;
        helper.should.not.be.undefined;
        mcnode.should.not.be.null;
        const flow = [
            Object.assign({ id: "n1", name: "mindconnect" }, nodeTemplate),
        ];
        helper.load(mcnode, flow, () => {
            const n1 = helper.getNode("n1");
            n1.should.have.property("name", "mindconnect");
            n1.should.have.property("configtype", "SHARED_SECRET");
            n1.should.have.property("validate", true);
            n1.should.have.property("retry", "3");
            done();
        });
    });
    mocha_1.it("should validate data before sending to MindSphere", (done) => {
        const flow = [
            Object.assign(Object.assign({ id: "n1" }, nodeTemplate), { wires: [["n2"]] }),
            { id: "n2", type: "helper" },
        ];
        helper.load(mcnode, flow, () => {
            const n1 = helper.getNode("n1");
            const n2 = helper.getNode("n2");
            n2.on("input", (msg) => {
                msg.should.have.property("_mindsphereStatus", "Error");
                done();
            });
            const values = [{ datapoint: "unexistent", qualityCode: "244", value: "42" }];
            n1.receive({ _time: new Date(), payload: values });
        });
    });
    mocha_1.it("should send timeseries data to MindSphere", (done) => {
        const flow = [
            Object.assign(Object.assign({ id: "n1" }, nodeTemplate), { wires: [["n2"]] }),
            { id: "n2", type: "helper" },
        ];
        helper.load(mcnode, flow, () => __awaiter(void 0, void 0, void 0, function* () {
            const n1 = helper.getNode("n1");
            const agent = n1.agent;
            const config = yield agent.GetDataSourceConfiguration();
            const n2 = helper.getNode("n2");
            n2.on("input", (msg) => {
                msg.should.have.property("_mindsphereStatus", "OK");
                done();
            });
            const values = [];
            config.dataSources.forEach((dataSource) => {
                dataSource.dataPoints.forEach((datapoint) => {
                    values.push({
                        dataPointId: datapoint.id.toString(),
                        qualityCode: "0",
                        value: Math.floor(Math.random() * 101).toString(),
                    });
                });
            });
            n1.receive({ _time: new Date(), payload: values });
        }));
    });
    mocha_1.it("should send bulk timeseries data to MindSphere", (done) => {
        const flow = [
            Object.assign(Object.assign({ id: "n1" }, nodeTemplate), { wires: [["n2"]] }),
            { id: "n2", type: "helper" },
        ];
        helper.load(mcnode, flow, () => __awaiter(void 0, void 0, void 0, function* () {
            const n1 = helper.getNode("n1");
            const agent = n1.agent;
            const config = yield agent.GetDataSourceConfiguration();
            const n2 = helper.getNode("n2");
            n2.on("input", (msg) => {
                msg.should.have.property("_mindsphereStatus", "OK");
                done();
            });
            const values = [];
            config.dataSources.forEach((dataSource) => {
                dataSource.dataPoints.forEach((datapoint) => {
                    values.push({
                        dataPointId: datapoint.id.toString(),
                        qualityCode: "0",
                        value: Math.floor(Math.random() * 101).toString(),
                    });
                });
            });
            n1.receive({ payload: [{ timestamp: new Date().toISOString(), values: values }] });
        }));
    });
    mocha_1.it("should send events to mindsphere", (done) => {
        const flow = [
            Object.assign(Object.assign({ id: "n1" }, nodeTemplate), { wires: [["n2"]] }),
            { id: "n2", type: "helper" },
        ];
        helper.load(mcnode, flow, () => {
            const n1 = helper.getNode("n1");
            const n2 = helper.getNode("n2");
            n2.on("input", (msg) => {
                msg.should.have.property("_mindsphereStatus", "OK");
                done();
            });
            n1.receive({
                payload: {
                    sourceType: "UnitTest Agent",
                    sourceId: "application",
                    source: "MindConnect Agent",
                    severity: 40,
                    description: "Event sent at " + new Date().toISOString(),
                    timestamp: new Date().toISOString(),
                },
            });
        });
    });
    mocha_1.it("should send files to mindsphere", (done) => {
        const flow = [
            Object.assign(Object.assign({ id: "n1" }, nodeTemplate), { wires: [["n2"]] }),
            { id: "n2", type: "helper" },
        ];
        helper.load(mcnode, flow, () => {
            const n1 = helper.getNode("n1");
            const n2 = helper.getNode("n2");
            n2.on("input", (msg) => {
                msg.should.have.property("_mindsphereStatus", "OK");
                done();
            });
            n1.receive({
                payload: {
                    fileName: "README.md",
                    description: `File last uploaded on ${new Date().toISOString()}`,
                    filePath: `uploads/${new Date().getTime()}/README.md`,
                },
            });
        });
    });
});
//# sourceMappingURL=mindconnect-node.spec.js.map