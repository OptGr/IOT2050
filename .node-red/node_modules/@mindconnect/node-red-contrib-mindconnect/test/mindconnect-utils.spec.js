"use strict";
// Copyright Siemens AG, 2019
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
const mocha_1 = require("mocha");
const mindconnect_utils_1 = require("../src/mindconnect-utils");
const helper = require("node-red-node-test-helper");
helper.init(require.resolve("node-red"));
chai.should();
mocha_1.describe("MindConnect Utils", () => {
    mocha_1.it("should be able to asynchronously wait @ci", () => __awaiter(void 0, void 0, void 0, function* () {
        mindconnect_utils_1.sleep.should.not.be.undefined;
        const then = new Date();
        yield mindconnect_utils_1.sleep(500);
        const now = new Date();
        (now.getTime() - then.getTime()).should.be.gte(490);
    }));
    mocha_1.it("should be able to retry with node log @ci", () => __awaiter(void 0, void 0, void 0, function* () {
        let retries = 0;
        const mock = { log: () => { }, status: () => { } };
        yield mindconnect_utils_1.retryWithNodeLog(5, () => {
            if (retries++ < 2)
                throw new Error("not yet");
        }, "Test", mock);
        retries.should.be.greaterThan(2);
    }));
    mocha_1.it("should be able to copy configuration @ci", () => __awaiter(void 0, void 0, void 0, function* () {
        const config = {
            name: "Hello",
            configtype: "SHARED_SECRET",
            agentconfig: {
                content: {
                    baseUrl: "https://southgate.eu1.mindsphere.io",
                    iat: "...",
                    clientCredentialProfile: ["SHARED_SECRET"],
                    clientId: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                    tenant: "castidev",
                },
                expiration: new Date("2018-11-15T17:31:35.000Z"),
            },
            privatekey: "xx",
            model: "yy",
            validate: true,
            validateevent: false,
            chunk: true,
            disablekeepalive: true,
            retry: "2",
            parallel: "1",
            asyncduration: "3",
            emitcontrol: false,
            datalakeonly: false,
            supressverbosity: false,
        };
        const target = {};
        mindconnect_utils_1.copyConfiguration(target, config);
        target.should.be.deep.equal(config);
        target.privatekey.should.be.equal("xx");
        target.chunk.should.be.true;
    }));
    mocha_1.it("should be able to configure agent @ci", () => __awaiter(void 0, void 0, void 0, function* () {
        const config = {
            name: "Hello",
            configtype: "SHARED_SECRET",
            agentconfig: {
                content: {
                    baseUrl: "https://southgate.eu1.mindsphere.io",
                    iat: "...",
                    clientCredentialProfile: ["SHARED_SECRET"],
                    clientId: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                    tenant: "castidev",
                },
                expiration: new Date("2018-11-15T17:31:35.000Z"),
            },
            privatekey: "xx",
            model: "yy",
            validate: true,
            validateevent: false,
            chunk: true,
            disablekeepalive: true,
            retry: "2",
            parallel: "1",
            asyncduration: "3",
        };
        const mock = { log: () => { }, status: () => { } };
        mindconnect_utils_1.configureAgent(mock, config);
        mock.agent.should.not.be.undefined;
        mock.agent._configuration.should.not.be.undefined;
        mock.should.be.deep.include(config);
    }));
    mocha_1.it("should be able to validate correct configuration @ci", () => __awaiter(void 0, void 0, void 0, function* () {
        const config = {
            name: "Hello",
            configtype: "RSA_3072",
            agentconfig: {
                content: {
                    baseUrl: "https://southgate.eu1.mindsphere.io",
                    iat: "...",
                    clientCredentialProfile: ["RSA_3072"],
                    clientId: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                    tenant: "castidev",
                },
                expiration: new Date("2018-11-15T17:31:35.000Z"),
            },
            privatekey: "-----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY-----\n",
            model: "yy",
            validate: true,
            validateevent: false,
            chunk: true,
            disablekeepalive: false,
            retry: "2",
            parallel: "1",
            asyncduration: "3",
        };
        let errorCalled = false;
        let logCalled = false;
        const errors = [];
        const mock = {
            log: () => {
                logCalled = true;
            },
            status: () => { },
            error: (x) => {
                errors.push(x);
                errorCalled = true;
            },
        };
        mindconnect_utils_1.configureAgent(mock, config);
        mock.agent.should.not.be.undefined;
        mock.agent._configuration.should.not.be.undefined;
        mock.should.be.deep.include(config);
        errorCalled.should.be.false;
        errors.length.should.equal(0);
        logCalled.should.be.true;
    }));
    mocha_1.it("should be able to throw an error on incorrect certificate @ci", () => __awaiter(void 0, void 0, void 0, function* () {
        const config = {
            name: "Hello",
            configtype: "RSA_3072",
            agentconfig: {
                content: {
                    baseUrl: "https://southgate.eu1.mindsphere.io",
                    iat: "...",
                    clientCredentialProfile: ["RSA_3072"],
                    clientId: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                    tenant: "castidev",
                },
                expiration: new Date("2018-11-15T17:31:35.000Z"),
            },
            privatekey: "-----BEGIN RSA PRIVATE KEY-----\n",
            model: "yy",
            validate: true,
            validateevent: false,
            chunk: true,
            disablekeepalive: true,
            retry: "2",
            parallel: "1",
            asyncduration: "3",
        };
        let errorCalled = false;
        const errors = [];
        const mock = {
            log: () => { },
            status: () => { },
            error: (x) => {
                errors.push(x);
                errorCalled = true;
            },
        };
        mindconnect_utils_1.configureAgent(mock, config);
        mock.agent.should.not.be.undefined;
        mock.agent._configuration.should.not.be.undefined;
        mock.should.be.deep.include(config);
        errorCalled.should.be.true;
        errors.length.should.equal(1);
        errors[0].toString().should.include("END RSA PRIVATE KEY");
    }));
});
//# sourceMappingURL=mindconnect-utils.spec.js.map